[{"path":"index.html","id":"introducción","chapter":"1 Introducción","heading":"1 Introducción","text":"En este ejercicio se empieza con utilizar archivos .Rmd y cada archivo RMarkdown puede contener un capítulo o varios encabezados dependiendo del tema.Tutorial de Bookdownbookdown: Authoring Books Technical Documents R Markdown o bien citando al autor Yihui Xie1","code":""},{"path":"index.html","id":"rmarkdown","chapter":"1 Introducción","heading":"1.1 RMarkdown","text":"R Markdown: Definitive Guide\nR Markdown: Reference GuideEn RStudio, se puede crear un nuevo archivo .Rmd desde el menú File -> New File -> R Markdown.Hay tres componentes básicos de un documento RMarkdown: los metadatos, el texto y el código.Sintax de los metadatos conocido como: YALM. Donde este tipo de formato es imporante conservar la sangría dentro del YAML y también es importante que todos los subcampos esten en el lugar correcto. Sino enviará error la hora de exportar los archivos.YAMLChunkUn fragmento de código comienza con tres acentos “backticks” como ```{r} donde r indica el nombre del idioma, y termina con tres acentos.También se puede escribir opciones de fragmentos entre llaves (por ejemplo, establecer la altura de la figura en 5 pulgadas: ```{r, fig.height=5}).También se puede escribir opciones de fragmentos entre llaves (por ejemplo, establecer la altura de la figura en 5 pulgadas: ```{r, fig.height=5}).Una expresión de código R en línea comienza `r termina con un acento `.Una expresión de código R en línea comienza `r termina con un acento `.","code":"---\ntitle: \"Hello R Markdown\"\nauthor: \"Awesome Me\"\ndate: \"2018-02-14\"\noutput: html_document\n---"},{"path":"index.html","id":"knitr","chapter":"1 Introducción","heading":"1.2 Knitr","text":"Elegant, flexible, fast dynamic report generation R\nFigure 1.1: diagram illustrating R Markdown document converted final output document.\nLa forma habitual de compilar un documento R Markdown es hacer clic en el Knit y el atajo de teclado correspondiente es Ctrl + Shift + K o bien RStudio llama la función rmarkdown::render() para representar el documento en una nueva sesión de R. Cuando se tienen varios formatos de salida en los metadatos y se desea utilizar el primero, se puede especificar el que desea en el segundo argumento, por ejemplo, para un documento RMD se establece una salida foo.Rmd con los metadatos:Puede convertirlo en PDF través de:Mail merge RMarkdown","code":"output:\n  html_document:\n    toc: true\n  pdf_document:\n    keep_tex: true\nrmarkdown::render('foo.Rmd', 'pdf_document')"},{"path":"rmarkdown-1.html","id":"rmarkdown-1","chapter":"2 RMarkdown","heading":"2 RMarkdown","text":"","code":""},{"path":"rmarkdown-1.html","id":"footnotes","chapter":"2 RMarkdown","heading":"2.1 Footnotes","text":"Footnotes put inside square brackets caret ^[]. Like one 2.","code":""},{"path":"rmarkdown-1.html","id":"citations","chapter":"2 RMarkdown","heading":"2.2 Citations","text":"Reference items bibliography file(s) using @key.example, using bookdown package3 (check last code chunk index.Rmd see citation key added) sample book, built top R Markdown knitr4 (citation added manually external file book.bib).\nNote .bib files need listed index.Rmd YAML bibliography key.bs4_book theme makes footnotes appear inline click . example book, added csl: chicago-fullnote-bibliography.csl index.Rmd YAML, include .csl file. download new style, recommend: https://www.zotero.org/styles/RStudio Visual Markdown Editor can also make easier insert citations: https://rstudio.github.io/visual-markdown-editing/#/citations","code":""},{"path":"chunks.html","id":"chunks","chapter":"3 Chunks","heading":"3 Chunks","text":"Elegant, flexible, fast dynamic report generation REl paquete knitr proporciona muchas opciones de fragmentos de código chunk para personalizar casi todos los componentes de los chunks, como el código fuente, la salida de texto, los gráficos (tamaño, resolución, salida) y el idioma del fragmento.Se puede insertar un fragmento de código chunk en R utilizando la barra de herramientas de RStudio Code -> Insert Chunk o el método abreviado Ctrl + Alt + .Se tiene un control preciso sobre todos los resultados través de las opciones dentro de los chunk, que se pueden proporcionar dentro de las llaves (```{r y })). Por ejemplo, se puede elegir ocultar la salida de texto través de la opción results = 'hide' dentro del chunk o establecer la altura de la figura en 4 pulgadas través de fig.height = 4. Las opciones de fragmentos están separadas por comas, por ejemplo,Hay una gran cantidad de opciones de chunks en knitr documentadas en https://yihui.name/knitr/options .\nUn subconjunto de ellos se muestran continuación:eval: Ya sea para evaluar un fragmento de código | eval = TRUE o eval = FALSE.echo: Si se desea mostrar el código de R en el documento de salida (es posible que alguien prefiera leer el código sino solo los resultados o imágenes) | echo = TRUE o echo = FALSE.results: cuando se establece en results = 'hide', la salida de texto se ocultará;Cuando se establece en results = 'asis'la salida de texto es tal cual, es decir, los resultados del texto se muestran sin formato directamente en el documento de salida sin formato desde el código R.results = 'markup'.results = 'markup'.results = 'asis'.results = 'asis'.results = 'hold'.results = 'hold'.colapse: Sirve para fusionar la salida de texto y el código fuente en un solo bloque de código en la salida. Esto es principalmente cosmético: collapse = TRUE hace que la salida sea más compacta, ya que el código fuente de R y su salida de texto se muestran en un solo bloque de salida. El valor predeterminado collapse = FALSE significa que las expresiones R y su salida de texto se separan en diferentes bloques.colapse: Sirve para fusionar la salida de texto y el código fuente en un solo bloque de código en la salida. Esto es principalmente cosmético: collapse = TRUE hace que la salida sea más compacta, ya que el código fuente de R y su salida de texto se muestran en un solo bloque de salida. El valor predeterminado collapse = FALSE significa que las expresiones R y su salida de texto se separan en diferentes bloques.warning, message y error: Muestra las advertencias, mensajes y errores en el documento de salida. Si se tiene en cuenta que si establece error = FALSE, el documento de salida se detendrá ante un error en un fragmento de código y el error se mostrará en la consola R. Del mismo modo, cuando warning = FALSE o message = FALSE, estos mensajes se mostrarán en la consola R. Siempre es preferible que se muestren errores en la salida del RMarkdown.warning, message y error: Muestra las advertencias, mensajes y errores en el documento de salida. Si se tiene en cuenta que si establece error = FALSE, el documento de salida se detendrá ante un error en un fragmento de código y el error se mostrará en la consola R. Del mismo modo, cuando warning = FALSE o message = FALSE, estos mensajes se mostrarán en la consola R. Siempre es preferible que se muestren errores en la salida del RMarkdown.include: Si se debe incluir algo de un fragmento de código en el documento de salida. Cuando include = FALSE, todo el chunk se excluye en la salida, pero teniendo en cuenta que aún se evaluará si se pone la opción eval = TRUE. Cuando se establecen las opciones: echo = FALSE, results = 'hide', warning = FALSE y message = FALSE, es probable que simplemente se refiera una sola opción include = FALSE en lugar de suprimir diferentes tipos de salida de texto individualmente.include: Si se debe incluir algo de un fragmento de código en el documento de salida. Cuando include = FALSE, todo el chunk se excluye en la salida, pero teniendo en cuenta que aún se evaluará si se pone la opción eval = TRUE. Cuando se establecen las opciones: echo = FALSE, results = 'hide', warning = FALSE y message = FALSE, es probable que simplemente se refiera una sola opción include = FALSE en lugar de suprimir diferentes tipos de salida de texto individualmente.cache: Se usa para habilitar el almacenamiento en caché. Si el almacenamiento en caché está habilitado cache = TRUE, el mismo fragmento de código se evaluará la próxima vez que se compile el documento (si se modificó el fragmento de código), lo que puede ahorrar tiempo. Dependiendo del código que se esté trabajando, conviene veces habilitarlo para ahorrar tiempo.cache: Se usa para habilitar el almacenamiento en caché. Si el almacenamiento en caché está habilitado cache = TRUE, el mismo fragmento de código se evaluará la próxima vez que se compile el documento (si se modificó el fragmento de código), lo que puede ahorrar tiempo. Dependiendo del código que se esté trabajando, conviene veces habilitarlo para ahorrar tiempo.fig.width y fig.height: El tamaño de salida del gráfico en R se representa en pulgadas.También se puede especificar las dos opciones juntas en una sola opción fig.dim, por ejemplo, los fig.dim = c(6, 4) o bien fig.width = 6 y fig.height = 4.fig.width y fig.height: El tamaño de salida del gráfico en R se representa en pulgadas.También se puede especificar las dos opciones juntas en una sola opción fig.dim, por ejemplo, los fig.dim = c(6, 4) o bien fig.width = 6 y fig.height = 4..width y .height: El tamaño de salida de las gráficas R en el documento de salida. Estas opciones pueden escalar las imágenes / fotos / gráficos. Se puede usar en porcentajes, por ejemplo, .width = '80%' significa 80% del ancho de la página..width y .height: El tamaño de salida de las gráficas R en el documento de salida. Estas opciones pueden escalar las imágenes / fotos / gráficos. Se puede usar en porcentajes, por ejemplo, .width = '80%' significa 80% del ancho de la página.fig.align: La alineación de los gráficos. Pueden ser 'left', 'center' o 'right'.fig.align: La alineación de los gráficos. Pueden ser 'left', 'center' o 'right'.fig.cap: El pie de figura, por ejemplo, fig.cap = 'Este es el pie del gráfico'.fig.cap: El pie de figura, por ejemplo, fig.cap = 'Este es el pie del gráfico'.","code":"```{r, chunk-label, results='hide', fig.height=4}```{r, results='asis'}\ncat(\"I'm raw **Markdown** content.\\n\")\n```"},{"path":"chunks.html","id":"setup","chapter":"3 Chunks","heading":"3.1 Setup","text":"Si una determinada opción debe configurarse con frecuencia en un varios chunks de todo el código, se puede considerar configurarla globalmente en el primer fragmento de código del RMarkdonwn que siempre aparece por default, por ejemplo:Además de fragmentos de código chunk, también puede insertar valores de objetos de R en líneas dentro del texto. Por ejemplo:","code":"```{r, setup, include=FALSE}\nknitr::opts_chunk$set(fig.width = 8, collapse = TRUE, echo = TRUE, eval = TRUE, fig.align = 'center')\n``````{r}\nx = 5  # radius of a circle\n```\n\nFor a circle with the radius `r x`,\nits area is `r pi * x^2`."},{"path":"objetos.html","id":"objetos","chapter":"4 Tipos de variables","heading":"4 Tipos de variables","text":"En R existen varios tipos de objectos que permiten que el usuario pueda almacenar la información para realizar procedimientos estadísticos y gráficos. Los principales objetos en R son vectores, matrices, arreglos, marcos de datos y listas. continuación se presentan las características de estos objetos y la forma para crearlos.","code":""},{"path":"objetos.html","id":"variables","chapter":"4 Tipos de variables","heading":"4.1 Variables","text":"Las variables sirven para almacenar un valor en el enviroment que luego vamos utilizar en algún procedimiento.Para hacer la asignación de un valor alguna variable se utiliza el operador <- entre el valor y el nombre de la variable. continuación un ejemplo sencillo.En el siguiente ejemplo se crea la variable pais y se almacena el nombre Colombia, luego se averigua el número de caracteres de la variable pais.","code":"\nx <- 5\n2 * x + 3\n## [1] 13\npais <- \"Colombia\"\nnchar(pais)## [1] 8"},{"path":"objetos.html","id":"null-y-na","chapter":"4 Tipos de variables","heading":"4.1.1 NULL y NA","text":"La expresión NA se usa en R para indicar un valor faltante. Considere el siguiente ejemplo. Recomendaciones, las funciones nativas de R, siempre es preferible usarlas como nombres de variables en el ambiente de trabajo.","code":"\nvec <- c(3, NA, 5)\nvec## [1]  3 NA  5"},{"path":"objetos.html","id":"vectores","chapter":"4 Tipos de variables","heading":"4.2 Vectores ","text":"Los vectores vectores son arreglos ordenados en los cuales se puede almacenar información de tipo numérico (variable cuantitativa), alfanumérico (variable cualitativa) o lógico (TRUE o FALSE), pero mezclas de éstos.\nLa función de R para crear un vector es c() y que significa concatenar; dentro de los paréntesis de esta función se ubica la información almacenar. Una vez construído el vector se acostumbra etiquetarlo con un nombre corto y representativo de la información que almacena, la asignación se hace por medio del operador <- entre el nombre y el vector.continuación se presenta un ejemplo de cómo crear tres vectores que contienen las respuestas de cinco personas tres preguntas que se les realizaron.El vector edad es un vector cuantitativo y contiene las edades de las 5 personas. En la cuarta posición del vector se colocó el símbolo NA que significa Available debido que se registró la edad para esa persona. Al hacer una asignación se acostumbra dejar un espacio antes y después del operador <- de asignación.El segundo vector es llamado deporte y es un vector lógico que almacena las respuestas la pregunta de si la persona practica deporte, nuevamente aquí hay un NA para la tercera persona.El último vector comic_fav contiene la información del cómic favorito de cada persona, como esta variable es cualitativa es necesario usar las comillas ' ' para encerrar las respuestas.Si se desea ver lo que está almacenado en cada uno de estos vectores, se debe escribir en la consola de R el nombre de uno de los objetos y luego se presionar CTRL + ENTER, al realizar esto, permite correr todo el chunk continuación.","code":"\nedad <- c(15, 19, 13, NA, 20)\ndeporte <- c(TRUE, TRUE, NA, FALSE, TRUE)\ncomic_fav <- c(NA, 'Superman', 'Batman', NA, 'Batman')\nedad\n## [1] 15 19 13 NA 20\ndeporte\n## [1]  TRUE  TRUE    NA FALSE  TRUE\ncomic_fav\n## [1] NA         \"Superman\" \"Batman\"   NA         \"Batman\""},{"path":"objetos.html","id":"cómo-extraer-elementos-de-un-vector","chapter":"4 Tipos de variables","heading":"4.2.1 ¿Cómo extraer elementos de un vector?","text":"Para extraer un elemento almacenado dentro un vector se usan los corchetes [] y dentro de ellos la posición o posiciones que interesan.","code":""},{"path":"objetos.html","id":"ejemplo","chapter":"4 Tipos de variables","heading":"Ejemplo","text":"Si se quiere extraer la edad de la tercera persona escribimos el nombre del vector y luego [3] para indicar la tercera posición de edad, continuación el código.Si se quiere conocer el cómic favorito de la segunda y quinta persona, escribimos el nombre del vector y luego, dentro de los corchetes, escribimos otro vector con las posiciones 2 y 5 que nos interesan así [c(2, 5)], continuación el código.Si nos interesan las respuestas de la práctica de deporte, excepto la de la persona 3, usamos [-3] luego del nombre del vector para obtener todo, excepto la tercera posición.","code":"\nedad[3]## [1] 13\ncomic_fav[c(2, 5)]## [1] \"Superman\" \"Batman\"\ndeporte[-3]## [1]  TRUE  TRUE FALSE  TRUE"},{"path":"objetos.html","id":"matrices","chapter":"4 Tipos de variables","heading":"4.3 Matrices","text":"Las matrices son arreglos rectangulares de filas y columnas con información numérica, alfanumérica o lógica. Para construir una matriz se usa la función matrix( ). Por ejemplo, para crear una matriz de 4 filas y 5 columnas (de dimensión \\(4 \\times 5\\)) con los primeros 20 números positivos se escribe el código siguiente en la consola.El argumento data de la función sirve para indicar los datos que se van almacenar en la matriz, los argumentos nrow y ncol sirven para definir la dimensión de la matriz y por último el argumento byrow sirve para indicar si la información contenida en data se debe ingresar por filas o .","code":"\nmimatriz <- matrix(data = 1:20, nrow = 4, ncol = 5, byrow = FALSE)\nmimatriz##      [,1] [,2] [,3] [,4] [,5]\n## [1,]    1    5    9   13   17\n## [2,]    2    6   10   14   18\n## [3,]    3    7   11   15   19\n## [4,]    4    8   12   16   20"},{"path":"objetos.html","id":"cómo-extraer-elementos-de-una-matriz","chapter":"4 Tipos de variables","heading":"4.3.1 ¿Cómo extraer elementos de una matriz?","text":"Al igual que en el caso de los vectores, para extraer elementos almacenados dentro de una matriz se usan los corchetes [ , ] y dentro, separado por una coma, el número de fila(s) y el número de columna(s) que nos interesan.","code":""},{"path":"objetos.html","id":"ejemplo-1","chapter":"4 Tipos de variables","heading":"Ejemplo","text":"Si se quiere extraer el valor almacenado en la fila 3 y columna 4 usamos el siguiente código.Si se quiere recuperar toda la fila 2 se usa el siguiente código.Si se quiere recuperar toda la columna 5 usamos el siguiente código.Si se quiere recuperar la matriz original sin las columnas 2 y 4 usamos el siguiente código.Si se quiere recuperar la matriz original sin la fila 1 ni columna 3 usamos el siguiente código.","code":"\nmimatriz[3, 4]## [1] 15\nmimatriz[2, ]  # No se escribe nada luego de la coma## [1]  2  6 10 14 18\nmimatriz[, 5]  # No se escribe nada antes de la coma## [1] 17 18 19 20\nmimatriz[, -c(2, 4)]  # Las columnas como vector##      [,1] [,2] [,3]\n## [1,]    1    9   17\n## [2,]    2   10   18\n## [3,]    3   11   19\n## [4,]    4   12   20\nmimatriz[-1, -3]  # Signo de menos para eliminar##      [,1] [,2] [,3] [,4]\n## [1,]    2    6   14   18\n## [2,]    3    7   15   19\n## [3,]    4    8   16   20"},{"path":"objetos.html","id":"arreglos","chapter":"4 Tipos de variables","heading":"4.4 Arreglos ","text":"Un arreglo es una matriz de varias dimensiones con información numérica, alfanumérica o lógica. Para construir una arreglo se usa la función array( ). Por ejemplo, para crear un arreglo de \\(3 \\times 4 \\times 2\\) con las primeras 24 letras minúsculas del alfabeto se escribe el siguiente código.El argumento data de la función sirve para indicar los datos que se van almacenar en el arreglo y el argumento dim sirve para indicar las dimensiones del arreglo. Para observar lo que quedó almacenado en el objeto miarray se escribe en la consola lo siguiente.","code":"\nmiarray <- array(data = letters[1:24], dim = c(3, 4, 2))\nmiarray## , , 1\n## \n##      [,1] [,2] [,3] [,4]\n## [1,] \"a\"  \"d\"  \"g\"  \"j\" \n## [2,] \"b\"  \"e\"  \"h\"  \"k\" \n## [3,] \"c\"  \"f\"  \"i\"  \"l\" \n## \n## , , 2\n## \n##      [,1] [,2] [,3] [,4]\n## [1,] \"m\"  \"p\"  \"s\"  \"v\" \n## [2,] \"n\"  \"q\"  \"t\"  \"w\" \n## [3,] \"o\"  \"r\"  \"u\"  \"x\""},{"path":"objetos.html","id":"cómo-extraer-elementos-de-un-arreglo","chapter":"4 Tipos de variables","heading":"4.4.1 ¿Cómo extraer elementos de un arreglo?","text":"Para recuperar elementos almacenados en un arreglo se usan también corchetes, y dentro de los corchetes, las coordenadas del objeto de interés.","code":""},{"path":"objetos.html","id":"ejemplo-2","chapter":"4 Tipos de variables","heading":"Ejemplo","text":"Si se quiere extraer la letra almacenada en la fila 1 y columna 3 de la segunda capa de miarray se usa el siguiente código.Si se quiere extraer la segunda capa completa usamos el siguiente código.Si se quiere extraer la tercera columna de todas las capas usamos el siguiente código.","code":"\nmiarray[1, 3, 2]  # El orden es importante## [1] \"s\"\nmiarray[,, 2]  # No se coloca nada en las primeras posiciones##      [,1] [,2] [,3] [,4]\n## [1,] \"m\"  \"p\"  \"s\"  \"v\" \n## [2,] \"n\"  \"q\"  \"t\"  \"w\" \n## [3,] \"o\"  \"r\"  \"u\"  \"x\"\nmiarray[, 3,]  # No se coloca nada en las primeras posiciones##      [,1] [,2]\n## [1,] \"g\"  \"s\" \n## [2,] \"h\"  \"t\" \n## [3,] \"i\"  \"u\""},{"path":"objetos.html","id":"data-frame","chapter":"4 Tipos de variables","heading":"4.5 Data Frame ","text":"El data frame_ o marco de datos es uno de los objetos más utilizados porque permite agrupar vectores con información de diferente tipo (numérica, alfanumérica o lógica) en un mismo objeto, la única restricción es que los vectores deben tener la misma longitud. Para crear un marco de datos se usa la función data.frame( ), como ejemplo, se va crear un marco de datos con los vectores edad, deporte y comic_fav definidos anteriormente.Una vez creado el objeto mimarco se puede ver el objeto escribiendo su nombre en la consola, continuación se muestra lo que se obtiene.De la salida anterior se ve que el marco de datos tiene 3 variables (columnas) cuyos nombres coinciden con los nombres de los vectores creados anteriormente, los números consecutivos al lado izquierdo son sólo de referencia y permiten identificar la información para cada persona en la base de datos.","code":"\nmimarco <- data.frame(edad, deporte, comic_fav)\nmimarco##   edad deporte comic_fav\n## 1   15    TRUE      <NA>\n## 2   19    TRUE  Superman\n## 3   13      NA    Batman\n## 4   NA   FALSE      <NA>\n## 5   20    TRUE    Batman"},{"path":"objetos.html","id":"cómo-extraer-elementos-de-un-marco-de-datos","chapter":"4 Tipos de variables","heading":"4.5.1 ¿Cómo extraer elementos de un marco de datos?","text":"Para recuperar las variables (columnas) almacenadas en un marco de datos se puede usar el operador $, corchetes simples [] o corchetes dobles [[]]. continuación algunos ejemplos para entender las diferencias entre estas opciones.","code":""},{"path":"objetos.html","id":"ejemplo-3","chapter":"4 Tipos de variables","heading":"Ejemplo","text":"Si se quiere extraer la variable deporte del marco de datos mimarco como un vector usamos el siguiente código.Otra forma de recuperar la variable deporte como vector es indicando el número de la columna donde se encuentra la variable.Otra forma de extraer la variable deporte como vector es usando [[]] y dentro el nombre de la variable.Si usamos mimarco[\"deporte\"] el resultado es la variable deporte pero en forma de marco de datos, en forma vectorial.Si se quiere extraer un marco de datos sólo con las variables deporte y edad se puede usar el siguiente código.Por otra, si se quiere la edad de las personas que están en las posiciones 2 hasta 4 usamos el siguiente código.","code":"\nmimarco$deporte  # Se recomienda si el nombre es corto## [1]  TRUE  TRUE    NA FALSE  TRUE\nmimarco[, 2]  # Se recomienda si recordamos su ubicacion## [1]  TRUE  TRUE    NA FALSE  TRUE\nmimarco[[\"deporte\"]]## [1]  TRUE  TRUE    NA FALSE  TRUE\nmimarco[\"deporte\"]##   deporte\n## 1    TRUE\n## 2    TRUE\n## 3      NA\n## 4   FALSE\n## 5    TRUE\nmimarco[c(\"deporte\", \"edad\")]\n##   deporte edad\n## 1    TRUE   15\n## 2    TRUE   19\n## 3      NA   13\n## 4   FALSE   NA\n## 5    TRUE   20\n\nmimarco[,c(2,1)]\n##   deporte edad\n## 1    TRUE   15\n## 2    TRUE   19\n## 3      NA   13\n## 4   FALSE   NA\n## 5    TRUE   20\nmimarco[2:4, 1]## [1] 19 13 NA"},{"path":"objetos.html","id":"cómo-extraer-subconjuntos-de-un-data.frame","chapter":"4 Tipos de variables","heading":"4.5.2 ¿Cómo extraer subconjuntos de un data.frame? ","text":"Para extraer partes de un marco de datos se puede utilizar la función subset(x, subset, select). El parámetro x sirve para indicar el marco de datos original, el parámetro subset sirve para colocar la condición y el parámetro select sirve para quedarnos sólo con algunas de las variables del marco de datos. continuación varios ejemplos de la función subset para ver su utilidad.","code":""},{"path":"objetos.html","id":"ejemplos","chapter":"4 Tipos de variables","heading":"Ejemplos","text":"Si se quiere que el marco de datos mimarco sólo con las personas que SI practican deporte usamos el siguiente código.Si se quiere el marco de datos mimarco sólo con las personas mayores o iguales 17 años usamos el siguiente código.Si se quiere el submarco con deporte y comic de las personas menores de 20 años usamos el siguiente código.Si se quiere el marco de datos mimarco sólo con las personas menores de 20 años y que SI practican deporte usamos el siguiente código.","code":"\nsubset(mimarco, subset = deporte == TRUE)##   edad deporte comic_fav\n## 1   15    TRUE      <NA>\n## 2   19    TRUE  Superman\n## 5   20    TRUE    Batman\nsubset(mimarco, subset = edad >= 17)##   edad deporte comic_fav\n## 2   19    TRUE  Superman\n## 5   20    TRUE    Batman\nsubset(mimarco, subset = edad < 20, select = c('deporte', 'comic_fav'))##   deporte comic_fav\n## 1    TRUE      <NA>\n## 2    TRUE  Superman\n## 3      NA    Batman\nsubset(mimarco, subset = edad < 20 & deporte == TRUE)##   edad deporte comic_fav\n## 1   15    TRUE      <NA>\n## 2   19    TRUE  Superman"},{"path":"objetos.html","id":"información-sobre-objetos","chapter":"4 Tipos de variables","heading":"4.5.3 Información sobre objetos","text":"Aquí hay una lista de funciones que menudo son útiles para obtener información sobre objetos en R.length devuelve el número de entradas en un vector.length devuelve el número de entradas en un vector.dim devuelve el número de filas y columnas de una matriz o un marco de datosdim devuelve el número de filas y columnas de una matriz o un marco de datosunique devuelve los elementos únicos de un vector o las filas únicas de una matriz o un marco de datos.unique devuelve los elementos únicos de un vector o las filas únicas de una matriz o un marco de datos.head devuelve las primeras entradas de un vector o las primeras filas de una matriz o un marco de datoshead devuelve las primeras entradas de un vector o las primeras filas de una matriz o un marco de datosorder devuelve una reordenación de un vector o un data.frame en orden ascendente.order devuelve una reordenación de un vector o un data.frame en orden ascendente.","code":"\nvec <- c(4,2,7,5,5)\n\nlength(vec)\n## [1] 5\n\nunique(vec)\n## [1] 4 2 7 5\n\norder(vec)\n## [1] 2 1 4 5 3"},{"path":"objetos.html","id":"ejemplo-4","chapter":"4 Tipos de variables","heading":"Ejemplo","text":"Leer la base de datos medidas del cuerpo disponible en este enlace https://raw.githubusercontent.com/fhernanb/datos/master/medidas_cuerpo. Extraer de esta base de datos una sub-base o subconjunto que contenga sólo la edad, peso, altura y sexo de aquellos que miden más de 185 cm y pesan más de 80 kg.Al almacenar la nueva base de datos en el objeto dt2 se puede manipular este nuevo objeto para realizar los análisis de interés.","code":"\nurl <- 'https://raw.githubusercontent.com/fhernanb/datos/master/medidas_cuerpo'\n\ndt1 <- read.table(url, header = T)\n\ndim(dt1)  # Para conocer la dimensión de la base original \n## [1] 36  6\n\ndt2 <- subset(x = dt1, subset = altura > 185 & peso > 80,\n               select = c('sexo', 'edad', 'peso', 'altura'))\ndt2  # Para mostrar la base de datos final\n##      sexo edad peso altura\n## 1  Hombre   43 87.3  188.0\n## 6  Hombre   33 85.9  188.0\n## 15 Hombre   30 98.2  190.5"},{"path":"objetos.html","id":"listas","chapter":"4 Tipos de variables","heading":"4.6 Listas ","text":"Las listas son otro tipo de objeto muy usado para almacenar objetos de diferente tipo. La instrucción para crear una lista es list( ). continuación vamos crear una lista que contiene tres objetos:\n- un vector con 5 números aleatorios llamado mivector,\n-una matriz de dimensión \\(6 \\times 2\\) con los primeros doce números enteros positivos llamada matriz2 y,\n- el tercer objeto será el marco de datos mimarco creado en el apartado anterior.Las instrucciones para crear la lista requerida se muestran continuación.La función set.seed de la línea número 1 sirve para fijar la semilla de tal manera que los números aleatorios generados en la segunda línea con la función runif sean siempre los mismos. En la última línea del código anterior se construye la lista, dentro de la función list se colocan los tres objetos mivector, matriz2 y mimarco. Es posible colocarle un nombre especial cada uno de los elementos de la lista, en este ejemplo se colocaron los nombres E1, E2 y E3 para cada uno de los tres elementos. Para observar lo que quedó almacenado en la lista se escribe milista en la consola y el resultado se muestra continuación.","code":"\nset.seed(12345)\nmivector <- runif(n = 5) \n\nmatriz2 <- matrix(data = 1:12, ncol = 6) \n\nmilista <- list(E1 = mivector, E2 = matriz2, E3 = mimarco)\nmilista## $E1\n## [1] 0.7209039 0.8757732 0.7609823 0.8861246 0.4564810\n## \n## $E2\n##      [,1] [,2] [,3] [,4] [,5] [,6]\n## [1,]    1    3    5    7    9   11\n## [2,]    2    4    6    8   10   12\n## \n## $E3\n##   edad deporte comic_fav\n## 1   15    TRUE      <NA>\n## 2   19    TRUE  Superman\n## 3   13      NA    Batman\n## 4   NA   FALSE      <NA>\n## 5   20    TRUE    Batman"},{"path":"objetos.html","id":"cómo-extraer-elementos-de-una-lista","chapter":"4 Tipos de variables","heading":"4.6.1 ¿Cómo extraer elementos de una lista?","text":"Para recuperar los elementos almacenadas en una lista se usa el operador $, corchetes dobles [[]] o corchetes sencillos []. continuación unos ejemplos para entender cómo extraer elementos de una lista.","code":""},{"path":"objetos.html","id":"ejemplos-1","chapter":"4 Tipos de variables","heading":"Ejemplos","text":"Si se quiere la matriz almacenada con el nombre de E2 dentro del objeto milista se puede usar el siguiente código.Es posible indicar la posición del objeto en lugar del nombre, para eso se usan los corchetes dobles.El resultado obtenido con milista$E2 y milista[[2]] es exactamente el mismo. Vamos se va solicitar la posición 2 pero usando corchetes sencillos.La apariencia de este último resultado es similar, igual, al encontrado al usar $ y [[]]. Para ver la diferencia vamos pedir la clase la que pertenecen los tres últimos objetos usando la función class. continuación el código usado.De lo anterior se observa claramente que cuando usamos $ o [[]] el resultado es el objeto almacenado, una matriz. Cuando usamos [] el resultado es una lista cuyo contenido es el objeto almacendado.¿Cuál es el error al correr el siguiente código? ¿qué se debe?","code":"\nmilista$E2##      [,1] [,2] [,3] [,4] [,5] [,6]\n## [1,]    1    3    5    7    9   11\n## [2,]    2    4    6    8   10   12\nmilista[[2]]##      [,1] [,2] [,3] [,4] [,5] [,6]\n## [1,]    1    3    5    7    9   11\n## [2,]    2    4    6    8   10   12\nmilista[2]## $E2\n##      [,1] [,2] [,3] [,4] [,5] [,6]\n## [1,]    1    3    5    7    9   11\n## [2,]    2    4    6    8   10   12\nclass(milista$E2)\n## [1] \"matrix\" \"array\"\n\nclass(milista[[2]])\n## [1] \"matrix\" \"array\"\n\nclass(milista[2])\n## [1] \"list\"\nedad <- c(15, 19, 13, NA, 20)\ndeporte <- c(TRUE, TRUE, NA, FALSE, TRUE)\ncomic_fav <- c(NA, 'Superman', 'Batman', NA, 'Batman')\nmatrix(edad, deporte, comic_fav)"},{"path":"propiedades-de-los-objetos.html","id":"propiedades-de-los-objetos","chapter":"5 Propiedades de los objetos","heading":"5 Propiedades de los objetos","text":"Las estructuras de datos son objetos que contienen datos. Cuando trabajamos con R, lo que estamos haciendo es manipular estas estructuras.Las estructuras tienen diferentes características. Entre ellas, las que distinguen una estructura de otra son su número de dimensiones y si son homogeneas o hereterogeneas.La siguiente tabla muestra las principales estructuras de control que te encontrarás en R.Veamos las características de cada una de ellas.","code":""},{"path":"propiedades-de-los-objetos.html","id":"vectores-1","chapter":"5 Propiedades de los objetos","heading":"5.1 Vectores","text":"Un vector es la estructura de datos más sencilla en R. Un vector es una colección de uno o más datos del mismo tipo.Todos los vectores tienen tres propiedades:Tipo. Un vector tiene el mismo tipo que los datos que contiene. Si tenemos un vector que contiene datos de tipo numérico, el vector será también de tipo numérico. Los vectores son atómicos, pues sólo pueden contener datos de un sólo tipo, es posible mezclar datos de tipos diferentes dentro de ellos.Tipo. Un vector tiene el mismo tipo que los datos que contiene. Si tenemos un vector que contiene datos de tipo numérico, el vector será también de tipo numérico. Los vectores son atómicos, pues sólo pueden contener datos de un sólo tipo, es posible mezclar datos de tipos diferentes dentro de ellos.Largo. Es el número de elementos que contiene un vector. El largo es la única dimensión que tiene esta estructura de datos.Largo. Es el número de elementos que contiene un vector. El largo es la única dimensión que tiene esta estructura de datos.Atributos. Los vectores pueden tener metadatos de muchos tipos, los cuales describen características de los datos que contienen. Todos ellos son incluidos en esta propiedad. En este libro se usarán vectores con metadatos, por ser una propiedad con usos van más allá del alcance de este libro.Atributos. Los vectores pueden tener metadatos de muchos tipos, los cuales describen características de los datos que contienen. Todos ellos son incluidos en esta propiedad. En este libro se usarán vectores con metadatos, por ser una propiedad con usos van más allá del alcance de este libro.Cuando una estructura únicamente puede contener datos de un sólo tipo, como es el caso de los vectores, decimos que es homogénea, pero implica que necesariamente sea atómica. Regresaremos sobre esto al hablar de matrices y arrays.Como los vectores son la estructura de datos más sencilla de R, datos simples como el número 3, son en realidad vectores. En este caso, un vector de tipo numérico y largo igual 1.se verifica que el 3 es un vector con la función .vector().Y se usa la función length() para conocer su largo.Lo mismo ocurre con los demás tipos de datos, por ejemplo, con cadenas de texto y datos lógicos.","code":"\n3\n## [1] 3\nis.vector(3)\n## [1] TRUE\nlength(3)\n## [1] 1\nis.vector(\"tres\")\n## [1] TRUE\n\nis.vector(TRUE)\n## [1] TRUE"},{"path":"propiedades-de-los-objetos.html","id":"creación-de-vectores","chapter":"5 Propiedades de los objetos","heading":"5.1.1 Creación de vectores","text":"se crean vectores usando la función c() (concatenar).Llamamos esta función y le damos como argumento los elementos que deseamos combinar en un vector, separados por comas.Si se desea agregar un elemento un vector ya existente, se puede hacerlo combinando nuestro vector original con los elementos nuevos y asignando el resultado nuestro vector original.O bien si se desea cambiar un elemento dentro de un vector ya existente.Naturalmente, se pueden crear vectores que son combinación de vectores.Si se intentar combinar datos de diferentes tipos en un mismo vector, R realizará coerción automáticamente. El vector resultante será del tipo más flexible entre los datos que contenga, siguiendo las reglas de coerción.Se crea un vector numérico.Pero si se intenta agregar un dato de tipo cadena de texto, el vector resultante ahora será de tipo cadena de texto.Como las cadenas de texto son el tipo de dato más flexible, siempre quese creará un vector que incluye un dato de este tipo, el resultado será un vector de texto.Tambien se pueden crear vectores de secuencias numéricas usando :. De un lado de los dos puntos escribimos el número de inicio de la secuencia y del otro el final.Por ejemplo, se crea una secuencia del 1 al 10.También se puede crear una secuencia del 10 al 1.Las secuencias creadas con : son consecutivas con incrementos o decrementos de 1. Estas secuencias pueden empezar con cualquier número, incluso si este es negativo o tiene cifras decimales.Si un número de inicio tiene cifras decimales, estas serán respetadas al hacer los incrementos o decrementos de uno en uno. En contraste, si tiene el número final tiene cifras decimales, este será redondeado.","code":"\n# Vector numérico\nc(1, 2, 3, 5, 8, 13)\n## [1]  1  2  3  5  8 13\n\n# Vector de cadena de texto\nc(\"arbol\", \"casa\", \"persona\")\n## [1] \"arbol\"   \"casa\"    \"persona\"\n\n# Vector lógico\nc(TRUE, TRUE, FALSE, FALSE, TRUE)\n## [1]  TRUE  TRUE FALSE FALSE  TRUE\nmi_vector <- c(TRUE, FALSE, TRUE)\n\nmi_vector <- c(mi_vector, FALSE)\n\nmi_vector## [1]  TRUE FALSE  TRUE FALSE\nmi_vector <- c(TRUE, FALSE, TRUE)\nmi_vector[2] <- \"2\"\nmi_vector\n## [1] \"TRUE\" \"2\"    \"TRUE\"\nmi_vector_1 <- c(1, 3, 5)\nmi_vector_2 <- c(2, 4, 6)\nmi_vector_3 <- c(mi_vector_1, mi_vector_2)\nmi_vector_3\n## [1] 1 3 5 2 4 6\nmi_vector <- c(1, 2, 3)\nclass(mi_vector)\n## [1] \"numeric\"\nmi_vector_nuevo <- c(mi_vector, \"a\")\nclass(mi_vector_nuevo)\n## [1] \"character\"\nmi_vector_mezcla <- c(FALSE, 2, \"tercero\", 4.00)\nclass(mi_vector_mezcla)\n## [1] \"character\"\n1:10\n##  [1]  1  2  3  4  5  6  7  8  9 10\n10:1\n##  [1] 10  9  8  7  6  5  4  3  2  1\n# Número negativo\n-43:-30\n##  [1] -43 -42 -41 -40 -39 -38 -37 -36 -35 -34 -33 -32 -31 -30\n\n# Número con cifras decimales\n67.23:75\n## [1] 67.23 68.23 69.23 70.23 71.23 72.23 73.23 74.23\n# Se conservan los decimales del inicio\n-2.48:2\n## [1] -2.48 -1.48 -0.48  0.52  1.52\n\n56.007:50\n## [1] 56.007 55.007 54.007 53.007 52.007 51.007 50.007\n\n# Se redondean los decimales del final\n166:170.05\n## [1] 166 167 168 169 170\n\n968:960.928\n## [1] 968 967 966 965 964 963 962 961"},{"path":"propiedades-de-los-objetos.html","id":"vectorización-de-operaciones","chapter":"5 Propiedades de los objetos","heading":"5.1.2 Vectorización de operaciones","text":"Existen algunas operaciones al aplicarlas un vector, se aplican cada uno de sus elementos. este proceso le llamamos vectorización.Las operaciones aritméticas y relacionales pueden vectorizarse. Si las aplicamos un vector, la operación se realizará para cada uno de los elementos que contiene.Por ejemplo, se crea un vector numérico.Si se aplican operaciones aritméticas, se obtendrá un vector con un resultado por cada elemento.Al aplicar operaciones relacionales, se obtendrás un vector de TRUEy FALSE, uno para cada elemento comparado.De esta manera aplicar una operación es muy eficiente. Comparada con otros procedimientos, requiere de menos tiempo de cómputo, lo cual veces es considerable, en particular cuando se trabaja con un número grande de datos.Aunque el nombre de este proceso es vectorización, también funciona, en ciertas circunstancias, para otras estructuras de datos, principalmente para calculos matriciales.","code":"\nmi_vector <- c(2, 3, 6, 7, 8, 10, 11)\n# Operaciones aritméticas\nmi_vector + 2\n## [1]  4  5  8  9 10 12 13\n\nmi_vector * 2\n## [1]  4  6 12 14 16 20 22\n\nmi_vector %% 2\n## [1] 0 1 0 1 0 0 1\nmi_vector > 7\n## [1] FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE\n\nmi_vector < 7\n## [1]  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE\n\nmi_vector == 7\n## [1] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE"},{"path":"propiedades-de-los-objetos.html","id":"matrices-y-arrays","chapter":"5 Propiedades de los objetos","heading":"5.2 Matrices y arrays","text":"Las matrices y arrays pueden ser descritas como vectores multidimensionales. Al igual que un vector, únicamente pueden contener datos de un sólo tipo, pero además de largo, tienen más dimensiones.En un sentido estricto, las matrices son una caso especial de un array, que se distingue por tener específicamente dos dimensiones, un “largo”” y un “alto”. Las matrices son, por lo tanto, una estructura con forma rectangular, con renglones y columnas.Como las matrices son usadas de manera regular en matemáticas y estadística, es una estructura de datos de uso común en R.Los arrays, por su parte, pueden tener un número arbitrario de dimensiones. Pueden ser cubos, hipercubos y otras formas. Su uso es muy común en R, aunque veces es deseable contar con objetos n-dimensionales para manipular datos. Como los arrays tienen la restricción de que todos sus datos deben ser del mismo tipo, importando en cuántas dimensiones se encuentren, esto limita sus usos prácticos.En general, es preferible usar listas en lugar de arrays, una estructura de datos que además tienen ciertas ventajas que veremos más adelante.","code":""},{"path":"propiedades-de-los-objetos.html","id":"creación-de-matrices","chapter":"5 Propiedades de los objetos","heading":"5.2.1 Creación de matrices","text":"se crean matrices en R con la función matrix(). La función matrix() acepta dos argumentos, nrow y ncol. Con ellos se especifica el número de renglones y columnas que tendrá nuestra matriz. ?matrixLos datos que se intentan agrupar en una matriz serán acomodados en orden, de arriba abajo, y de izquierda derecha, hasta formar un rectángulo.Si se multiplica el número de renglones por el número de columnas, se obtandrá el número de celdas de la matriz. Donde el número de celdas es igual al número de elementos que se desea acomodar, así que la operación ocurre sin problemas.Cuando se intenta acomodar un número diferente de elementos y celdas, ocurren dos cosas diferentes.Si el número de elementos es mayor al número de celdas, se acomodarán todos los datos que sean posibles y los demás se omitirán.Si, por el contrario, el número de celdas es mayor que el número de elementos, estos se reciclaran. En cuanto los elementos sean insuficientes para acomodarse en las celdas, R nos devolverá una advertencia y se empezaran usar los elementos partir del primero de ellosOtro procedimiento para crear matrices es la unión vectores con las siguientes funciones:cbind() para unir vectores, usando cada uno como una columna.rbind() para unir vectores, usando cada uno como un renglón.De este modo se pueden crear cuatro vectores y unirlos para formar una matriz. Cada vector será un renglón en esta matriz.se crean cuatro vectores, cada uno de largo igual cuatro.Se usa rbind() para crear un matriz, en la que cada vector será un renglón.Si se utiliza cbind(), entonces cada vector será una columna.Al igual que con matrix(), los elementos de los vectores son reciclados para formar una estructura rectangular y se muestra un mensaje de advertencia.Finalmente, las matrices pueden contener NAs.Se crean dos vectores con un NA en ellos.Se crea una matriz con rbind().Como NA representa datos perdidos, se puede estar presente en compañía de todo tipo de de datos.","code":"\n# Un vector numérico del uno al doce\n1:12\n##  [1]  1  2  3  4  5  6  7  8  9 10 11 12\n\n# matrix() sin especificar renglones ni columnas\nmatrix(1:12)\n##       [,1]\n##  [1,]    1\n##  [2,]    2\n##  [3,]    3\n##  [4,]    4\n##  [5,]    5\n##  [6,]    6\n##  [7,]    7\n##  [8,]    8\n##  [9,]    9\n## [10,]   10\n## [11,]   11\n## [12,]   12\n\n# Tres renglones y cuatro columnas\nmatrix(1:12, nrow = 3, ncol = 4)\n##      [,1] [,2] [,3] [,4]\n## [1,]    1    4    7   10\n## [2,]    2    5    8   11\n## [3,]    3    6    9   12\n\n# Cuatro columnas y tres columnas\nmatrix(1:12, nrow = 4, ncol = 3)\n##      [,1] [,2] [,3]\n## [1,]    1    5    9\n## [2,]    2    6   10\n## [3,]    3    7   11\n## [4,]    4    8   12\n\n# Dos renglones y seis columnas\nmatrix(1:12, nrow = 4, ncol = 3)\n##      [,1] [,2] [,3]\n## [1,]    1    5    9\n## [2,]    2    6   10\n## [3,]    3    7   11\n## [4,]    4    8   12\nmatrix(1:12, nrow = 3, ncol = 3)\n## Warning in matrix(1:12, nrow = 3, ncol = 3): data length differs from size of matrix: [12 != 3 x 3]\n##      [,1] [,2] [,3]\n## [1,]    1    4    7\n## [2,]    2    5    8\n## [3,]    3    6    9\nmatrix(1:12, nrow = 5, ncol = 4)\n## Warning in matrix(1:12, nrow = 5, ncol = 4): data length [12] is not a sub-multiple or multiple of the number of rows\n## [5]\n##      [,1] [,2] [,3] [,4]\n## [1,]    1    6   11    4\n## [2,]    2    7   12    5\n## [3,]    3    8    1    6\n## [4,]    4    9    2    7\n## [5,]    5   10    3    8\nvector_1 <- 1:4\nvector_2 <- 5:8\nvector_3 <- 9:12\nvector_4 <- 13:16\nmatriz <- rbind(vector_1, vector_2, vector_3, vector_4)\n# Resultado\nmatriz\n##          [,1] [,2] [,3] [,4]\n## vector_1    1    2    3    4\n## vector_2    5    6    7    8\n## vector_3    9   10   11   12\n## vector_4   13   14   15   16\nmatriz <- cbind(vector_1, vector_2, vector_3, vector_4)\n# Resultado\nmatriz\n##      vector_1 vector_2 vector_3 vector_4\n## [1,]        1        5        9       13\n## [2,]        2        6       10       14\n## [3,]        3        7       11       15\n## [4,]        4        8       12       16\n# Elementos de largo diferente\nvector_1 <- 1:2\nvector_2 <- 1:3\nvector_3 <- 1:5\nmatriz <- cbind(vector_1, vector_2, vector_3)\n## Warning in cbind(vector_1, vector_2, vector_3): number of rows of result is not a multiple of vector length (arg 1)\n# Resultado\nmatriz\n##      vector_1 vector_2 vector_3\n## [1,]        1        1        1\n## [2,]        2        2        2\n## [3,]        1        3        3\n## [4,]        2        1        4\n## [5,]        1        2        5\nvector_1 <- c(NA, 1, 2)\nvector_2 <- c(3,  4, NA)\nmatriz <- rbind(vector_1, vector_2)\n# Resultados\nmatriz\n##          [,1] [,2] [,3]\n## vector_1   NA    1    2\n## vector_2    3    4   NA"},{"path":"propiedades-de-los-objetos.html","id":"propiedades-de-las-matrices","chapter":"5 Propiedades de los objetos","heading":"5.2.2 Propiedades de las matrices","text":"obstante que las matrices y arrays son estructuras que sólo pueden contener un tipo de datos, son atómicas. Su clase es igual matriz (matrix) o array según corresponda.se verifica esto usando la función class().Las matrices y arrays pueden tener más de una dimensión.Obtenemos el número de dimensiones de una matriz o array con la función dim(). Esta función nos devolverá varios números, cada uno de ellos indica la cantidad de elementos que tiene una dimensión.Cabe señalar que si se usa dim() con un vector, obtenemos NULL. Esto ocurre con todos los objetos unidimensionalesFinalmente, las operaciones aritméticas también son vectorizadas al aplicarlas una matriz. La operación es aplicada cada uno de los elementos de la matriz.Se crea una matriz de demensión \\(3\\times3\\).Se intenta sumar, multiplicar y elevar la tercera potencia.Se intenta vectorizar una operación utilizando una matriz con NAs, esta se aplicará para los elementos válidos, devolviendo NA cuando corresponda.Se crean una matriz con NAs.Se intenta dividir sus elementos entre dos.Finalmente, se puede usar la función t() para transponer una matriz, es decir, rotarla.Se crea una matriz con tres renglones y dos columnas.Se usa t() para transponer.Obtenemos una matriz con dos renglones y dos columnas.","code":"\nmi_matriz <- matrix(1:10)\nclass(mi_matriz)\n## [1] \"matrix\" \"array\"\nmi_matriz <- matrix(1:12, nrow = 4, ncol = 3)\ndim(mi_matriz)\n## [1] 4 3\nmi_vector <- 1:12\ndim(mi_vector)\n## NULL\nmi_matriz <- matrix(1:9, nrow = 3, ncol = 3)\n# Resultado\nmi_matriz\n##      [,1] [,2] [,3]\n## [1,]    1    4    7\n## [2,]    2    5    8\n## [3,]    3    6    9\n# Suma\nmi_matriz + 1\n##      [,1] [,2] [,3]\n## [1,]    2    5    8\n## [2,]    3    6    9\n## [3,]    4    7   10\n\n# Multiplicación\nmi_matriz * 2\n##      [,1] [,2] [,3]\n## [1,]    2    8   14\n## [2,]    4   10   16\n## [3,]    6   12   18\n\n# Potenciación\nmi_matriz ^ 3\n##      [,1] [,2] [,3]\n## [1,]    1   64  343\n## [2,]    8  125  512\n## [3,]   27  216  729\nvector_1 <- c(NA, 2, 3)\nvector_2 <- c(4, 5, NA)\nmatriz <- rbind(vector_1, vector_2)\n# Resultado\nmatriz\n##          [,1] [,2] [,3]\n## vector_1   NA    2    3\n## vector_2    4    5   NA\nmatriz / 2\n##          [,1] [,2] [,3]\n## vector_1   NA  1.0  1.5\n## vector_2    2  2.5   NA\nmatriz <- matrix(1:6, nrow = 3)\n# Resultado\nmatriz\n##      [,1] [,2]\n## [1,]    1    4\n## [2,]    2    5\n## [3,]    3    6\nmatriz_t <- t(matriz)\n# Resultado\nmatriz_t\n##      [,1] [,2] [,3]\n## [1,]    1    2    3\n## [2,]    4    5    6"},{"path":"propiedades-de-los-objetos.html","id":"data-frames","chapter":"5 Propiedades de los objetos","heading":"5.3 Data frames","text":"Los data frames son estructuras de datos de dos dimensiones (rectangulares) que pueden contener datos de diferentes tipos, por lo tanto, son heterogéneas. Esta estructura de datos es la más usada para realizar análisis de datos y el muy común trabajarlos con otros paquetes estadísticos.Se puede entender los data frames como una versión más flexible de una matriz. Mientras que en una matriz todas las celdas deben contener datos del mismo tipo, los renglones de un data frame admiten datos de distintos tipos, pero sus columnas conservan la restricción de contener datos de un sólo tipo.En términos generales, los renglones en un data frame representan casos, individuos u observaciones, mientras que las columnas representan atributos, rasgos o variables.Por ejemplo, así lucen los primeros cinco renglones del objeto iris, el famoso conjunto de datos Iris de Ronald Fisher, que está incluido en todas las instalaciones de R.Los primeros cinco renglones corresponden cinco casos, en este caso flores. Las columnas son variables con los rasgos de cada flor: largo y ancho de sépalo, largo y ancho de pétalo, y especie.Para crear un data frame se usa la función data.frame(). Esta función nos pedirá un número de vectores igual al número de columnas que deseemos. Todos los vectores que proporcionemos deben tener el mismo largo.Esto es muy importante: Un data frame está compuesto por vectores.Más adelante se hará evidente porque esta característica de un data frame es sumamente importante y también, cómo se puede sacarle provecho.Además, se puede asignar un nombre cada vector, que se convertirá en el nombre de la columna. Como todos los nombres, es recomendable que este sea claro, ambiguo y descriptivo.Si los vectores que se usa para construir el data frame son del mismo largo, los datos se reciclaran. Se nos devolverá un error.También se puede coercionar esta matriz un data frame.Se crea una matriz.Se usa .data.frame() para coercionar una matriz un data frame.Se verifica la clase de objeto es df.","code":"\nhead(iris, 5)##   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n## 1          5.1         3.5          1.4         0.2  setosa\n## 2          4.9         3.0          1.4         0.2  setosa\n## 3          4.7         3.2          1.3         0.2  setosa\n## 4          4.6         3.1          1.5         0.2  setosa\n## 5          5.0         3.6          1.4         0.2  setosa\ntail(iris, 5)##     Sepal.Length Sepal.Width Petal.Length Petal.Width   Species\n## 146          6.7         3.0          5.2         2.3 virginica\n## 147          6.3         2.5          5.0         1.9 virginica\n## 148          6.5         3.0          5.2         2.0 virginica\n## 149          6.2         3.4          5.4         2.3 virginica\n## 150          5.9         3.0          5.1         1.8 virginica\nmi_df <- data.frame(\n                    \"entero\" = 1:4, \n                    \"factor\" = c(\"a\", \"b\", \"c\", \"d\"), \n                    \"numero\" = c(1.2, 3.4, 4.5, 5.6),\n                    \"cadena\" = as.character(c(\"a\", \"b\", \"c\", \"d\"))\n                    )\nmi_df\n##   entero factor numero cadena\n## 1      1      a    1.2      a\n## 2      2      b    3.4      b\n## 3      3      c    4.5      c\n## 4      4      d    5.6      d\n\n# se puede usar dim() en un data frame\ndim(mi_df)\n## [1] 4 4\n\n# El largo de un data frame es igual a su número de columnas\nlength(mi_df)\n## [1] 4\n\n# names() nos permite ver los nombres de las columnas\nnames(mi_df)\n## [1] \"entero\" \"factor\" \"numero\" \"cadena\"\n\n# La clase de un data frame es data.frame\nclass(mi_df) \n## [1] \"data.frame\"\ndata.frame(\n  \"entero\" = 1:3, \n  \"factor\" = c(\"a\", \"b\", \"c\", \"d\"), \n  \"numero\" = c(1.2, 3.4, 4.5, 5.6),\n  \"cadena\" = as.character(c(\"a\", \"b\", \"c\", \"d\"))\n)\nmatriz <- matrix(1:12, ncol = 4)\ndf <- as.data.frame(matriz)\nclass(df)\n## [1] \"data.frame\"\n\n# Resultado\ndf\n##   V1 V2 V3 V4\n## 1  1  4  7 10\n## 2  2  5  8 11\n## 3  3  6  9 12"},{"path":"propiedades-de-los-objetos.html","id":"propiedades-de-un-data-frame","chapter":"5 Propiedades de los objetos","heading":"5.3.1 Propiedades de un data frame","text":"Al igual que con una matriz, si aplicamos una operación aritmética un data frame, esta se vectorizará.Los resultados que obtendremos dependerán del tipo de datos de cada columna. R nos devolverá todas las advertencias que ocurran como resultado de las operaciones realizadas, por ejemplo, aquellas que hayan requerido una coerción.","code":"\nmi_df <- data.frame(\n  \"entero\" = 1:4, \n  \"factor\" = c(\"a\", \"b\", \"c\", \"d\"), \n  \"numero\" = c(1.2, 3.4, 4.5, 5.6),\n  \"cadena\" = as.character(c(\"a\", \"b\", \"c\", \"d\"))\n)\nmi_df * 2\nmi_df[,1] * 2\ndf$V1 *2"},{"path":"propiedades-de-los-objetos.html","id":"listas-1","chapter":"5 Propiedades de los objetos","heading":"5.4 Listas","text":"Las listas, al igual que los vectores, son estructuras de datos unidimensionales, sólo tienen largo, pero diferencia de los vectores cada uno de sus elementos puede ser de diferente tipo o incluso de diferente clase, por lo que son estructuras heterogéneas.Se pueden tener listas que contengan datos atómicos (diferentes), vectores, matrices, arrays, data frames u otras listas. Esta última característica es la razón por la que una lista puede ser considerada un vector recursivo, pues es un objeto que puede contener objetos de su misma clase.Para crear una lista se usa la función list(), que nos pedirá los elementos que deseamos incluir en nuestra lista. Para esta estructura, importan las dimensiones o largo de los elementos que queramos incluir en ella.Al igual que con un data frame, tenemos la opción de poner nombre cada elemento de una lista.Por último, es posible vectorizar operaciones aritméticas usando una lista, se nos devuelve un error como resultado.Se crean una lista que contiene otras listas.","code":"\nmi_vector <- 1:10\nmi_matriz <- matrix(1:4, nrow = 2)\nmi_df     <- data.frame(\"num\" = 1:3, \"let\" = c(\"a\", \"b\", \"c\"))\nmi_lista <- list(\"un_vector\" = mi_vector, \"una_matriz\" = mi_matriz, \"un_df\" = mi_df)\nmi_lista\n## $un_vector\n##  [1]  1  2  3  4  5  6  7  8  9 10\n## \n## $una_matriz\n##      [,1] [,2]\n## [1,]    1    3\n## [2,]    2    4\n## \n## $un_df\n##   num let\n## 1   1   a\n## 2   2   b\n## 3   3   c\nlista_recursiva <- list(\"lista1\" = mi_lista, \"lista2\" = mi_lista)\n# Resultado\nlista_recursiva\n## $lista1\n## $lista1$un_vector\n##  [1]  1  2  3  4  5  6  7  8  9 10\n## \n## $lista1$una_matriz\n##      [,1] [,2]\n## [1,]    1    3\n## [2,]    2    4\n## \n## $lista1$un_df\n##   num let\n## 1   1   a\n## 2   2   b\n## 3   3   c\n## \n## \n## $lista2\n## $lista2$un_vector\n##  [1]  1  2  3  4  5  6  7  8  9 10\n## \n## $lista2$una_matriz\n##      [,1] [,2]\n## [1,]    1    3\n## [2,]    2    4\n## \n## $lista2$un_df\n##   num let\n## 1   1   a\n## 2   2   b\n## 3   3   c"},{"path":"propiedades-de-los-objetos.html","id":"propiedades-de-una-lista","chapter":"5 Propiedades de los objetos","heading":"5.4.1 Propiedades de una lista","text":"Una lista es unidimensional, sólo tiene largo.El largo de una lista es igual al número de elementos que contiene, sin importar de qué tipo o clase sean. se usa la lista recursiva que se crean en la sección anterior para ilustrar esto.Dado que una lista siempre tiene una sola dimensión, la función dim() nos devuelve NULL.Las listas tienen clase list, sin importar qué elementos contienen.Finalmente, es posible vectorizar operaciones aritméticas usando listas. Al intentarlo nos es devuelto un error.Si se aplicar una función cada elemento de una lista, se usa lapply(). Para volver generar un lista como resultado.","code":"\nlength(lista_recursiva)\n## [1] 2\ndim(lista_recursiva)\n## NULL\nclass(lista_recursiva)\n## [1] \"list\"\nmi_lista / 2\n## Error in mi_lista/2: non-numeric argument to binary operator"},{"path":"coerción-de-objetos.html","id":"coerción-de-objetos","chapter":"6 Coerción de objetos","heading":"6 Coerción de objetos","text":"Al igual que con los datos, cuando se intenta hacer operaciones con una estructura de datos, R intenta coercionarla al tipo apropiado para poder llevarlas cabo con éxito.También se puede usar alguna de las funciones de la familia () para coercionar de un tipo de estructura de datos. continuación se presentan las más comunes.Como podrás ver, las estructuras de datos más sencillas, (unidimensionales, homogéneas) pueden ser coercionadas otras más complejas (multidimensionales, heterogéneas), pero la operación inversa casi nunca es posible.Veamos algunos ejemplos.Se crean un vector, una matriz, un data frame y una lista.Se intenta coercionar vector con .vector().La coerción que se intenta sólo tuvo éxito para una matriz. Para data frame y lista, nos devolvió los mismos objetos.Nota que .vector() devolvió un error o una advertencia pesar de que tuvo éxito al coercionar, en este caso un data frame o una lista. Esto es importante, pues puedes confiar que .vector() tuvo éxito porque corrió sin errores, es necesaria una verificación adicional. Como R intenta coercionar automáticamente, esto puede producir resultados inesperados si tenemos cuidado.Intentemos coercionar matriz con .matrix().El vector fue coercionado una matriz con una sola columna. Por su parte, al correr la función con un data frame, coercionamos también todos los datos que contiene.Al coercionar una lista una matriz, efectivamente se obtiene un objeto de este tipo, sin embargo se pierde toda la información que contiene, por lo tanto, se puede considerar que esta es una coerción exitosa. Del mismo modo que con .vector(), nos es mostrado ningún error ni advertencia.Se intentará coercionar matriz con .data.frame().Se tuvo éxito al coercionar vectores y matrices.El vector, al igual que cuando fue coercionado matriz, devolvió como resultado un objeto con una sola columna, mientras que la matriz conservó sus renglones y columnas.En este caso, al intentar la coerción de lista data frame, se obtiene un error. Esta es la única situación en la que esto ocurre utilizando las funciones revisadas en esta sección.Por último, se intentará coercionar matriz con .list().Dado que las listas son el tipo de objeto más flexible de todos, se coerccionaron con tenido éxito en todos los casos.Nota.- Para los vectores y matrices, cada uno de los elementos es transformado en un elemento dentro de la lista resultante. Si se obtuviera una matriz con cuarenta y ocho celdas, obtendríamos una lista con ese mismo número de elementos.En cambio, para un data frame, el resultado es una lista, en la que cada elemento contiene los datos de una columna del data frame original. Un data frame con diez columnas resultará en una lista de diez elementos.Conocer cómo ocurre la coerción de estructuras de datos te ayudará entender mejor algunos resultados devueltos por funciones de R, Además de que te facilitará la manipulación y procesamiento de datos.","code":"\nmi_vector <- c(\"a\", \"b\", \"c\")\nmi_matriz <- matrix(1:4, nrow = 2)\nmi_df <- data.frame(\"a\" = 1:2, \"b\" = c(\"a\", \"b\"))\nmi_lista <- list(\"a\" = mi_vector, \"b\" = mi_matriz, \"c\" = mi_df)\nas.vector(mi_matriz)## [1] 1 2 3 4\nas.vector(mi_df)## $a\n## [1] 1 2\n## \n## $b\n## [1] \"a\" \"b\"\nas.vector(mi_lista)## $a\n## [1] \"a\" \"b\" \"c\"\n## \n## $b\n##      [,1] [,2]\n## [1,]    1    3\n## [2,]    2    4\n## \n## $c\n##   a b\n## 1 1 a\n## 2 2 b\nas.matrix(mi_vector)\n##      [,1]\n## [1,] \"a\" \n## [2,] \"b\" \n## [3,] \"c\"\n\nas.matrix(mi_df)\n##      a   b  \n## [1,] \"1\" \"a\"\n## [2,] \"2\" \"b\"\n\nas.matrix(mi_lista)\n##   [,1]        \n## a character,3 \n## b integer,4   \n## c data.frame,2\nas.data.frame(mi_vector)\n##   mi_vector\n## 1         a\n## 2         b\n## 3         c\n\nas.data.frame(mi_matriz)\n##   V1 V2\n## 1  1  3\n## 2  2  4\n\nas.data.frame(mi_lista)\n## Error in (function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, : arguments imply differing number of rows: 3, 2\nas.list(mi_vector)\n## [[1]]\n## [1] \"a\"\n## \n## [[2]]\n## [1] \"b\"\n## \n## [[3]]\n## [1] \"c\"\n\nas.list(mi_matriz)\n## [[1]]\n## [1] 1\n## \n## [[2]]\n## [1] 2\n## \n## [[3]]\n## [1] 3\n## \n## [[4]]\n## [1] 4\n\nas.list(mi_df)\n## $a\n## [1] 1 2\n## \n## $b\n## [1] \"a\" \"b\""},{"path":"tipos-de-datos.html","id":"tipos-de-datos","chapter":"7 Tipos de datos","heading":"7 Tipos de datos","text":"En R los datos pueden ser de diferentes tipos. Cada tipo tiene características particulares que lo distinguen de los demás. Entre otras cosas algunas operaciones sólo pueden realizarse con tipos de datos específicosEs importante revisar el tipo de datos más comunes en R y sus propiedades, así como la coerción entre tipos de datos.","code":""},{"path":"tipos-de-datos.html","id":"datos-más-comunes","chapter":"7 Tipos de datos","heading":"7.1 Datos más comunes","text":"Los tipos de datos de uso más común en R son los siguientes.Además de estos tipos, en R también contamos con datos complejos numéricos complejos (con una parte real y una imaginaria), raw (bytes), fechas y raster, entre otros. Estos tipos tiene aplicaciones muy específicas, por ejemplo, los datos de tipo fecha son ampliamente usados en economía, para análisis de series de tiempo.Se revisan las principales características de estos tipos de datos.","code":""},{"path":"tipos-de-datos.html","id":"entero-y-numérico","chapter":"7 Tipos de datos","heading":"7.2 Entero y numérico","text":"Como su nombre lo indica, los datos enteros representan números enteros, sin una parte decimal o fraccionaria, que pueden ser usados en operaciones matemáticas.Por su parte, como su nombre lo indica, los datos numéricos representan números, la diferencia de estos con los datos enteros es que tiene una parte decimal o fraccionaria.Los datos numéricos también son llamados doble o float (flotantes). Este nombre se debe que, en realidad, son números de doble precisión, pues tienen una parte entera y una fraccionaria decimal, y son llamados float debido que se usa un punto flotante para su representación computacional. Para fines prácticos, estos términos son sinónimos.","code":""},{"path":"tipos-de-datos.html","id":"cadena-de-texto","chapter":"7 Tipos de datos","heading":"7.3 Cadena de texto","text":"El tipo character representa texto y es fácil reconocerlo porque un dato siempre esta rodeado de comillas , simples '' o dobles \"\". De manera convencional, nos referimos este tipo de datos como cadenas de texto, es decir, secuencias de caracteres.Este es el tipo de datos más flexible de R, pues una cadena de texto puede contener letras, números, espacios, signos de puntuación y símbolos especiales.","code":""},{"path":"tipos-de-datos.html","id":"factor","chapter":"7 Tipos de datos","heading":"7.4 Factor","text":"Un factor es un tipo de datos específico R. Puede ser descrito como un dato numérico representado por una etiqueta.Supongamos que tenemos un conjunto de datos que representan el sexo de personas encuestadas por teléfono, pero estos se encuentran capturados con los números 1 y 2. El número 1 corresponde femenino y el 2 masculino.En R, se puede indicar que se nos muestre, en la consola y para otros análisis, los 1 como femenino y los 2 como masculino. Aunque para nuestra computadora, femenino tiene un valor de 1, pero nosotros se nos muestra la palabra femenino. De esta manera reducimos el espacio de almacenamiento necesario para nuestros datos.Este comportamiento es similar lo que ocurre con paquetes estadísticos comerciales como SPSS Statistics, en los que se puede asignar etiquetas los datos, dependiendo de su valor. La diferencia se encuentra en que R trata los factores de manera diferente un dato numérico.Por último, cada una de las etiquetas o valores que puedes asumir un factor se conoce como nivel o levels() en inglés. En nuestro ejemplo con femenino y masculino, tendríamos dos niveles.","code":""},{"path":"tipos-de-datos.html","id":"lógico","chapter":"7 Tipos de datos","heading":"7.5 Lógico","text":"Los datos de tipo lógico sólo tienen dos valores posibles: verdadero (TRUE) y falso (FALSE). Representan si una condición o estado se cumple, es verdadero, o , es falso.Este tipo de dato es, generalmente, el resultado de operaciones relacionales y lógicas, son esenciales para trabajar con **álgebra Booleana*. También toman mucha relevancia cuando se estran trabajando con funciones más complejas en R.Como este tipo de dato sólo admite dos valores específicos, es el más restrictivo de R.","code":""},{"path":"tipos-de-datos.html","id":"na-y-null","chapter":"7 Tipos de datos","heading":"7.6 NA y NULL","text":"En R, se usa NA para representar datos perdidos, mientras que NULL representa la ausencia de datos.La diferencia entre las dos es que un dato NULL aparece sólo cuando R intenta recuperar un dato y encuentra nada, mientras que NA es usado para representar de modo explícito datos perdidos, omitidos o que por alguna razón son faltantes.Por ejemplo, si tratamos de recuperar la edad de una persona encuestada que existe, obtendríamos un NULL, pues hay ningún dato que corresponda con ello. En cambio, si tratamos de recuperar su estado civil, y la persona encuestada contestó esta pregunta, obtendríamos un NA.NA además puede aparecer como resultado de una operación realizada, pero tuvo éxito en su ejecución.","code":""},{"path":"tipos-de-datos.html","id":"coerción","chapter":"7 Tipos de datos","heading":"7.7 Coerción","text":"En R, los datos pueden ser coercionados, es decir, forzados, para transformarlos de un tipo otro.La coerción es muy importante. Cuando pedimos R ejecutar una operación, intentará coercionar de manera implícita, sin avisarnos, los datos de su tipo original al tipo correcto que la permita realizar. Habrá ocasiones en las que R tenga éxito y la operación ocurra sin problemas, y otras en las que falle y obtengamos un error.Lo anterior ocurre porque todos los tipos de datos pueden ser transformados los demás, para ello se sigue una regla general.La coerción de tipos se realiza de los tipos de datos más restrictivos los más flexibles.Las coerciones ocurren en el siguiente orden.lógico \\(\\Rightarrow\\) entero \\(\\Rightarrow\\) numérico \\(\\Rightarrow\\) cadena de texto` (logical \\(\\Rightarrow\\) integer \\(\\Rightarrow\\) numeric \\(\\Rightarrow\\) character)Las coerciones pueden ocurrir en orden inverso. se puede coercionar un dato de tipo entero uno numérico, pero uno de cadena de texto numérico.Como los datos de tipo lógico sólo admiten dos valores (TRUE y FALSE), estos son los más restrictivos; mientras que los datos decadena de texto, al admitir cualquier cantidad y combinación de caracteres, son los más flexibles.Los factores son un caso particular para la coerción. Dado que son valores numéricos con etiquetas, pueden ser coercionados tipo numérico y cadena de texto; y los datos numéricos y cadena de texto pueden ser coercionados factor. Sin embargo, al coercionar un factor tipo numérico, perdemos sus niveles.Las variables carácter pueden coaccionarse ser factor, pero de manera inversa. (es tan sencillo hacerlo inverso).","code":""},{"path":"tipos-de-datos.html","id":"coerción-explícita-con-la-familia-as","chapter":"7 Tipos de datos","heading":"7.7.1 Coerción explícita con la familia as()","text":"También se puede hacer coerciones explícitas usando la familia de funciones ().Todas estas funciones aceptan como argumento datos o vectores. Cuando estas funciones tienen éxito en la coerción, nos devuelven datos del tipo pedido. Si fallan, obtenemos NA como resultado.Por ejemplo, intentemos convertir el número 5 una cadena de texto. Para ello se usa la función .character().Esta es una coerción válida, así que tenemos éxito. Pero, si se intenta convertir la palabra “cinco” un dato numérico, se obtendrá una advertencia y NA.Comprobemos el comportamiento especial de los factores.Se puede coercionar al número 5 y la palabra “cinco” en un factor.Se asigna la palabra “cinco” como factor al objeto factor_cinco.Ahora se puede coercionar factor_cinco cadena de texto y numérico.Si se coercciona un dato de tipo lógico numérico, TRUE siempre devolverá 1 y FALSE dará como resultado 0.Por último, la función .null() siempre devuelve NULL, sin importar el tipo de dato que demos como argumento.","code":"\nas.character(5)\n## [1] \"5\"\nas.numeric(\"cinco\")\n## Warning: NAs introduced by coercion\n## [1] NA\nas.factor(5)\n## [1] 5\n## Levels: 5\n\nas.factor(\"cinco\")\n## [1] cinco\n## Levels: cinco\nfactor_cinco <- as.factor(\"cinco\")\n#Resultado\nfactor_cinco\n## [1] cinco\n## Levels: cinco\n# Cadena de texto\nas.character(factor_cinco)\n## [1] \"cinco\"\n\n# Numérico\nas.numeric(factor_cinco)\n## [1] 1\nas.numeric(TRUE)\n## [1] 1\nas.numeric(FALSE)\n## [1] 0\n# Lógico\nas.null(FALSE)\n## NULL\n\n# Numérico\nas.null(457)\n## NULL\n\n# Cadena de texto\nas.null(\"palabra\")\n## NULL"},{"path":"tipos-de-datos.html","id":"verificar-el-tipo-de-un-dato","chapter":"7 Tipos de datos","heading":"7.8 Verificar el tipo de un dato","text":"En ocasiones, tenemos datos pero sabemos de simple vista qué tipo de datos son. Para esto casos, se puede usar la función class() para determinar el tipo de un dato. Esto es de utilidad para asegurarse que las operaciones que se desean realizar tendrán los datos apropiados para llevarse cabo con éxito.class() recibe como argumento un dato o vector y devuelve el nombre del tipo al que pertenece, en inglés.Por ejemplo, se verifica el tipo de datos que son 3, “3” y TRUE.","code":"\nclass(3)\n## [1] \"numeric\"\n\nclass(\"3\")\n## [1] \"character\"\n\nclass(TRUE)\n## [1] \"logical\""},{"path":"tipos-de-datos.html","id":"verificación-con-la-familia-de-funciones-is","chapter":"7 Tipos de datos","heading":"7.8.1 Verificación con la familia de funciones is()","text":"También se puede verificar si un dato es de un tipo específico con la familia de funciones ().Estas funciones toman como argumento un dato, si este es del tipo que estamos verificando, nos devolverán TRUE y en caso contrario devolverán FALSE.Por ejemplo, se verifica que 5 sea numérico.Se obtiene TRUE, pues es verdadero que es un dato numérico.De verifica que 5 sea de tipo cadena de texto.El resultado es FALSE, por lo tanto este es un dato de cadena de texto.Conociendo el tipo de datos con los que se está trabajando, nos aseguramos de que se obtendrá los resultados esperados para las operaciones que estemos realizando.","code":"\nis.numeric(5)\n## [1] TRUE\nis.character(5)\n## [1] FALSE"},{"path":"funbasicas.html","id":"funbasicas","chapter":"8 Funciones básicas de R","heading":"8 Funciones básicas de R","text":"En este capítulo se presentará lo que es una función y se mostrarán varias funciones básicas que son útiles para realizar diversas tareas.","code":""},{"path":"funbasicas.html","id":"qué-es-una-función-de-r","chapter":"8 Funciones básicas de R","heading":"8.1 ¿Qué es una función de R?","text":"En la figura de abajo se muestra una ilustración de lo que es una función o máquina general. Hay unas entradas (inputs) que luego son procesadas dentro de la caja para generar unas salidas (outputs).Las funciones en R se caracterizan por un nombre corto y que dé una idea de lo que hace la función. Los elementos que pueden ingresar (inputs) la función se llaman parámetros o argumentos y se ubican dentro de paréntesis, el cuerpo de la función se ubica dentro de llaves y es ahí donde se procesan los inputs para convertirlos en outputs, continuación se muestra la estructura general de una función.Cuando usamos una función sólo debemos escribir bien el nombre e ingresar correctamente los parámetros de la función, el cuerpo de la función ni lo vemos ni lo debemos modificar. continuación se presenta un ejemplo de cómo usar la función mean para calcular un promedio.","code":"nombre_de_funcion(parametro1, parametro2, ...) {\n  tareas internas\n  tareas internas\n  tareas internas\n  salida\n}\nnotas <- c(4.0, 1.3, 3.8, 2.0)  # Notas de un estudiante\nmean(notas)## [1] 2.775\n# Es importante revisar los parametos de la función mean()\n?mean\n\nnotas <- c(4.0, 1.3, 3.8, NA) \nmean(notas)## [1] NA\nnotas <- c(4.0, 1.3, 3.8, NA) \nmean(notas, na.rm = TRUE)## [1] 3.033333"},{"path":"funbasicas.html","id":"operadores-de-asignación","chapter":"8 Funciones básicas de R","heading":"8.2 Operadores de asignación","text":"En R se pueden hacer asignación de varias formas, continuación se presentan los operadores disponibles para tal fin.<- este es el operador de asignación izquierda, es el más usado y recomendado.-> este es el operador de asignación derecha, es frecuente su uso.= el símbolo igual sirve para hacer asignaciones pero se recomienda usarlo.<<- este es un operador de asignación global y sólo debe ser usado por usuarios avanzados.","code":""},{"path":"funbasicas.html","id":"ejemplo-5","chapter":"8 Funciones básicas de R","heading":"Ejemplo","text":"Almacene los valores 5.3, 4.6 y 25 en los objetos , b y age respectivamente, use diferentes símbolos de asignación.Para hacer lo solicitado se podría usar el siguiente código.","code":"\na <- 5.3 # Recomended\n4.6 -> b # It is not usual\nage = 25 # Not recomended"},{"path":"funbasicas.html","id":"operaciones-básicas","chapter":"8 Funciones básicas de R","heading":"8.3 Operaciones básicas","text":"En R se pueden hacer diversas operaciones usando operadores binarios. Este tipo de operadores se denomina binarios porque actuan entre dos objetos, continuación el listado.+ operador binario para sumar.- operador binario para restar.* operador binario para multiplicar./ operador binario para dividir.^ operador binario para potencia.%/% operador binario para obtener el cociente en una división (número entero).%% operador binario para obtener el residuo en una división.¨%*% operador binario para el producto suma de dos matricesA continuación se presentan ejemplos de cómo usar las anteriores funciones.","code":"\n6 + 4  # Para sumar dos números\n## [1] 10\na <- c(1, 3, 2)\nb <- c(2, 0, 1)  # a y b de la misma dimensión\n\na + b  # Para sumar los vectores a y b miembro a miembro\n## [1] 3 3 3\n\na - b  # Para restar dos vectores a y b miembro a miembro\n## [1] -1  3  1\n\na * b  # Para multiplicar\n## [1] 2 0 2\na / b  # Para dividir\n## [1] 0.5 Inf 2.0\n\na ^ b  # Para potencia\n## [1] 1 1 2\n\n7 %/% 3  # Para saber las veces que cabe 3 en 7\n## [1] 2\n\n7 %% 3  # Para saber el residuo al dividir 7 entre 3\n## [1] 1\n\na %*% b\n##      [,1]\n## [1,]    4"},{"path":"funbasicas.html","id":"pruebas-lógicas","chapter":"8 Funciones básicas de R","heading":"8.4 Pruebas lógicas","text":"En R se puede verificar si un objeto cumple una condición dada, continuación el listado de las pruebas usuales.< para saber si un número es menor que otro.> para saber si un número es mayor que otro.== para saber si un número es igual que otro.<= para saber si un número es menor o igual que otro.>= para saber si un número es mayor o igual que otro.!= para saber si un número es diferente que otro.continuación se presentan ejemplos de cómo usar las anteriores funciones.","code":"\n5 < 12  # ¿Será 5 menor que 12?\n## [1] TRUE\n\n# Comparando objetos\nx <- 5\ny <- 20 / 4\n\nx == y  # ¿Será x igual a y?\n## [1] TRUE\n\n# Usando vectores\na <- c(1, 3, 2)\nb <- c(2, 0, 1)\n\na > b  # Comparación término a término\n## [1] FALSE  TRUE  TRUE\n\na == b  # Comparación de igualdad término a término\n## [1] FALSE FALSE FALSE\n\na !=b # Si a es diferente de b\n## [1] TRUE TRUE TRUE"},{"path":"funbasicas.html","id":"ejemplo-6","chapter":"8 Funciones básicas de R","heading":"Ejemplo","text":"Crear un vector con los números de 1 17 y extrater los números que son mayores o iguales 12.Primero se crea el vector x con los elementos del 1 al 17. La prueba lógica x >= 12 se usa para evaluar la condición, el resultado es un vector de 17 posiciones con valores de TRUE o FALSE dependiendo de si la condición se cumple o . Este vector lógico se coloca dentro de x[ ] para que al evaluar x[x >= 12] sólo aparezcan los valores del vector original que SI cumplen la condición. El código necesario se muestra continuación.","code":"\nx <- 1:17  # Se crea el vector\nx[x >= 12]  # Se solicitan los valores que cumplen la condición## [1] 12 13 14 15 16 17"},{"path":"funbasicas.html","id":"ejemplo-7","chapter":"8 Funciones básicas de R","heading":"Ejemplo","text":"Se retoma el data.fram mimarco construído en la sección 3 y use una prueba lógica para extraer la información de las personas que tienen una edad superior o igual 15 años.Inicialmente vamos construir nuevamente el objeto mimarco de la seccióna anterior usando el siguiente código.Para extraer de mimarco la información de las personas que tienen una edad superior o igual 15 años se coloca dentro de corchetes la condición mimarco$edad >= 15, esto servirá para chequear cuáles de las edades del vector mimarco$ead cumplen la condición. El resultado de evaluar mimarco$edad >= 15 será un vector lógico (TRUE o FALSE), que al ser colocado dentro de mimarco[,], entregará la información de las personas que cumplen la condición. continuación el código para extraer la información solicitada.De la salida anterior se observa que 4 personas de las 5 cumplean la condición.","code":"\nmimarco <- data.frame(edad = c(15, 19, 13, NA, 20), \n                      deporte = c(TRUE, TRUE, NA, FALSE, TRUE),\n                      comic_fav = c(NA, 'Superman', 'Batman', NA, 'Batman'))\nmimarco  # Para ver el contenido de mimarco##   edad deporte comic_fav\n## 1   15    TRUE      <NA>\n## 2   19    TRUE  Superman\n## 3   13      NA    Batman\n## 4   NA   FALSE      <NA>\n## 5   20    TRUE    Batman\nmimarco[mimarco$edad >= 15, ]##    edad deporte comic_fav\n## 1    15    TRUE      <NA>\n## 2    19    TRUE  Superman\n## NA   NA      NA      <NA>\n## 5    20    TRUE    Batman"},{"path":"funbasicas.html","id":"operadores-lógicos","chapter":"8 Funciones básicas de R","heading":"8.5 Operadores lógicos","text":"En R están disponibles los operadores lógicos negación, conjunción y disyunción. continuación el listado de los operadores entre los elementos x e y.continuación se presentan ejemplos de cómo usar el símbolo de negación !.continuación se presentan ejemplos de cómo aplicar la conjunción & y &&.Notese las diferencias entre los dos últimos ejemplos, cuando se usa & se hace una prueba término término y el resultado es un vector, cuando se usa && se aplica la conjunción al vector de resultados obtenido con &.","code":"\n!x  # Negación de x\nx & y  # Conjunción entre x e y\nx && y\nx | y  # Disyunción entre x e y\nx || y\nxor(x, y)\nans <- c(TRUE, FALSE, TRUE)\n!ans  # Negando las respuestas almacenadas en ans\n## [1] FALSE  TRUE FALSE\n\nx <- c(5, 1.5, 2, 3, 2)\n\n!(x < 2.5)  # Negando los resultados de una prueba\n## [1]  TRUE FALSE FALSE  TRUE FALSE\nx <- c(5, 1.5, 2)  # Se construyen dos vectores para la prueba\ny <- c(4, 6, 3)\n\nx < 4  # ¿Serán los elementos de x menores que 4?\n## [1] FALSE  TRUE  TRUE\n\ny > 5  # ¿Serán los elementos de y mayores que 5?\n## [1] FALSE  TRUE FALSE\n\nx < 4 & y > 5  # Conjunción entre las pruebas anteriores.\n## [1] FALSE  TRUE FALSE\n\nx < 4 && y > 5  # Conjunción vectorial (Se usa para evaluar circuitos)\n## Warning in x < 4 && y > 5: 'length(x) = 3 > 1' in coercion to 'logical(1)'\n## [1] FALSE\n\n((-2:2) >= 0) & ((-2:2) <= 0)\n## [1] FALSE FALSE  TRUE FALSE FALSE\n\n((-2:2) >= 0) && ((-2:2) <= 0)\n## Warning in ((-2:2) >= 0) && ((-2:2) <= 0): 'length(x) = 5 > 1' in coercion to 'logical(1)'\n## [1] FALSE"},{"path":"funbasicas.html","id":"ejemplo-8","chapter":"8 Funciones básicas de R","heading":"Ejemplo","text":"Se toma el data.frame mimarco construído en la sección 3 y una prueba lógica para extraer la información de las personas que tienen una edad superior o igual 15 años y que practican deporte.Aquí interesa extraer la información de los individuos que cumplen dos condiciones simultáneamente, aquellos con edad \\(\\geq\\) 15 y que SI practiquen deporte. El código necesario para obtener la información solicitada es el siguiente.De la anterior salida se observa que sólo 3 de las 5 personas cumplen ambas condiciones.Una forma alternativa para escribir lo anterior usando la función es la siguiente.Al usar sólo se tuvo que escribir el objeto mimarco dos veces. Cuando hay muchas condiciones o cuando el objeto tiene un nombre largo es aconsejable usar .","code":"\nmimarco[mimarco$edad >= 15 & mimarco$deporte == TRUE, ]##   edad deporte comic_fav\n## 1   15    TRUE      <NA>\n## 2   19    TRUE  Superman\n## 5   20    TRUE    Batman\nwith(mimarco, mimarco[edad >= 15 & deporte == TRUE, ])##   edad deporte comic_fav\n## 1   15    TRUE      <NA>\n## 2   19    TRUE  Superman\n## 5   20    TRUE    Batman"},{"path":"funbasicas.html","id":"funciones-sobre-vectores","chapter":"8 Funciones básicas de R","heading":"8.6 Funciones sobre vectores","text":"En R se puede destacar las siguientes funciones básicas sobre vectores numéricos.min: para obtener el mínimo de un vector.max: para obtener el máximo de un vector.length: para determinar la longitud de un vector.range: para obtener el rango de valores de un vector, entrega el mínimo y máximo.sum: entrega la suma de todos los elementos del vector.prod: multiplica todos los elementos del vector..min: nos entrega la posición en donde está el valor mínimo del vector..max: nos da la posición del valor máximo del vector.rev: invierte un vector.","code":""},{"path":"funbasicas.html","id":"ejemplo-9","chapter":"8 Funciones básicas de R","heading":"Ejemplo","text":"Construir en vector llamado myvec con los siguientes elementos: 5, 3, 2, 1, 2, 0, NA, 0, 9, 6. Luego aplicar todas las funciones anteriores para verificar el funcionamiento de las mismas.De las dos últimas líneas se puede destacar lo siguiente:es necesario usar na.rm = TRUE para remover el NA dentro de las funciones .min ni .max.El valor mínimo 0 aparece en las posiciones 6 y 8 pero la función .min sólo entrega la posición del primer valor mínimo dentro del vector.","code":"\nmyvec <- c(5, 3, 2, 1, 2, 0, NA, 0, 9, 6)\nmyvec\n##  [1]  5  3  2  1  2  0 NA  0  9  6\n\nmin(myvec)  # Opss, no aparece el mínimo que es Cero.\n## [1] NA\n\nmin(myvec, na.rm=TRUE)  # Usamos na.rm = TRUE para remover el NA\n## [1] 0\n\nmax(myvec, na.rm=T)  # Para obtener el valor máximo\n## [1] 9\n\nrange(myvec, na.rm=T)  # Genera min y max simultáneamente\n## [1] 0 9\n\nsum(myvec, na.rm=T)  # La suma de los valores internos\n## [1] 28\n\nprod(myvec, na.rm=T)  # El productor de los valores internos\n## [1] 0\n\nwhich.min(myvec)  # Posición del valor mínimo 0 en el vector\n## [1] 6\n\nwhich.max(myvec)  # Posición del valor máximo 9 en el vector\n## [1] 9"},{"path":"funbasicas.html","id":"funciones-matemáticas","chapter":"8 Funciones básicas de R","heading":"8.7 Funciones matemáticas","text":"Otras funciones básicas muy utilizadas en estadística son: sin, cos, tan, asin, acos, atan, atan2, log, logb, log10, exp, sqrt, abs. continuación algunos ejemplos de las anteriores funciones.Ejemplos de medidas trigonométricasEjemplos de logaritmosEjemplos de exponencialEjemplos de raicesEjemplos de valor absoluto","code":"\nangulos <- c(0, pi/2, pi)\nsin(angulos)\n## [1] 0.000000e+00 1.000000e+00 1.224606e-16\n\ntan(angulos)\n## [1]  0.000000e+00  1.633124e+16 -1.224647e-16\nlog(100)\n## [1] 4.60517\n\nlog10(100)\n## [1] 2\n\nlogb(125, base=5)\n## [1] 3\nexp(1)\n## [1] 2.718282\n\nexp(2)\n## [1] 7.389056\n\nexp(1:3)\n## [1]  2.718282  7.389056 20.085537\nsqrt(49)  # Raiz cuadrada de 49\n## [1] 7\n\n27 ^ (1/3)  # Raiz cúbica de 27\n## [1] 3\nabs(2.5)\n## [1] 2.5\n\nabs(-3.6)\n## [1] 3.6"},{"path":"funbasicas.html","id":"función-seq","chapter":"8 Funciones básicas de R","heading":"8.8 Función seq","text":"En R se puede crear secuencias de números de una forma sencilla usando la función seq, la estructura de esta función es:Los argumentos de esta función son:: valor de inicio de la secuencia.: valor de fin de la secuencia, siempre se alcanza.: incremento de la secuencia.length.: longitud deseado de la secuencia.","code":"\nseq(from = 1, to = 1, by, length.out)"},{"path":"funbasicas.html","id":"ejemplo-10","chapter":"8 Funciones básicas de R","heading":"Ejemplo","text":"Construya las siguientes tres secuencias usando la función seq.valores igualmente espaciados desde 0 hasta 1.Una secuencia de dos en dos comenzando en 1.Una secuencia desde 1 con un salto de \\(\\pi\\) y sin pasar del número 9.El código necesario para obtener las secuencias se muestra continuación.Revise los siguientes ejemplos para entender el funcionamiento del operador :.","code":"\nseq(from = 0, to = 1, length.out = 11)\n##  [1] 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0\n\nseq(from = 1, to = 9, by = 2)  # matches 'end'\n## [1] 1 3 5 7 9\n\nseq(from = 1, to = 9, by = pi) # stays below 'end'\n## [1] 1.000000 4.141593 7.283185\n2:8\n## [1] 2 3 4 5 6 7 8\n\n3:-5\n## [1]  3  2  1  0 -1 -2 -3 -4 -5\n\npi:6  # real sequence\n## [1] 3.141593 4.141593 5.141593\n\n6:pi  # integer sequence\n## [1] 6 5 4"},{"path":"funbasicas.html","id":"función-rep","chapter":"8 Funciones básicas de R","heading":"8.9 Función rep","text":"En R se puede crear repeticiones usando la función rep, la estructura de esta función es:Los argumentos de esta función son:x: vector con los elementos repetir.times: número de veces que el vector x se debe repetir.length.: longitud deseada para el vector resultante.: número de veces que cada elemento de x se debe repetir.","code":"\nrep(x, times = 1, length.out = NA, each = 1)"},{"path":"funbasicas.html","id":"ejemplo-11","chapter":"8 Funciones básicas de R","heading":"Ejemplo","text":"Se constuyen las siguientes repeticiones usando la función rep, lo hagas ingresando número por número.1 2 3 4 1 2 3 41 1 2 2 3 3 4 41 1 2 3 3 41 1 2 2 3 3 4 4La clave para construir una repetición es descrubir la semilla o elemento que se repite. Las instrucciones para obtener las repeticiones anteriores se muestra continuación.","code":"\nrep(x = 1:4, times = 2)\n## [1] 1 2 3 4 1 2 3 4\n\nrep(x = 1:4, times = c(2,2,2,2))\n## [1] 1 1 2 2 3 3 4 4\n\nrep(x = 1:4, times = c(2,1,2,1))\n## [1] 1 1 2 3 3 4\n\nrep(x = 1:4, each = 2)\n## [1] 1 1 2 2 3 3 4 4"},{"path":"funbasicas.html","id":"ejemplo-12","chapter":"8 Funciones básicas de R","heading":"Ejemplo","text":"La función rep es muy versátil, observe los siguientes 4 ejemplos y saque una conclusión de cada uno de ellos.","code":"\nrep(x = 4, each = 2)\n## [1] 4 4\n\nrep(x = 1:4, each = 2, len = 4)    # first 4 only.\n## [1] 1 1 2 2\n\nrep(x = 1:4, each = 2, len  = 10)   # 8 integers plus two recycled 1's.\n##  [1] 1 1 2 2 3 3 4 4 1 1\n\nrep(x = 1:4, each = 2, times = 3)  # length 24, 3 complete replications\n##  [1] 1 1 2 2 3 3 4 4 1 1 2 2 3 3 4 4 1 1 2 2 3 3 4 4"},{"path":"funbasicas.html","id":"funciones-round-ceiling-floor-y-trunc","chapter":"8 Funciones básicas de R","heading":"8.10 Funciones round, ceiling, floor y trunc","text":"Existen 4 funciones útiles para modificar u obtener información de un número, estas funciones son round, ceiling, floor y trunc.round(x, digits): sirve para redondear un número según los dígitos indicados.ceiling(x): entrega el mínimo entero mayor o igual que x.floor(x): entrega el máximo entero menor o igual que x.trunc(x): entrega la parte entera de un número x.","code":""},{"path":"funbasicas.html","id":"ejemplo-13","chapter":"8 Funciones básicas de R","heading":"Ejemplo","text":"Aplique las funciones round, ceiling, floor y trunc un valor positivo y un valor negativo para inspeccionar los resultados.continuación el código de prueba para un número positivo cualquiera.continuación las pruebas con un número negativo cualquiera.","code":"\nx <- 5.34896  # Número positivo elegido\nround(x, digits=3)\n## [1] 5.349\n\nceiling(x)\n## [1] 6\n\nfloor(x)\n## [1] 5\n\ntrunc(x)\n## [1] 5\nx <- -4.26589  # Número negativo elegido\nround(x, digits=3)\n## [1] -4.266\n\nceiling(x)\n## [1] -4\n\nfloor(x)\n## [1] -5\n\ntrunc(x)\n## [1] -4"},{"path":"funbasicas.html","id":"funciones-sort-y-rank","chapter":"8 Funciones básicas de R","heading":"8.11 Funciones sort y rank","text":"Las funciones sort y rank son útiles para ordenar los elementos de un vector o para saber las posiciones que ocuarían los elementos de un vector al ser ordenado. La estructura de las dos funciones es la siguiente.En el parámetro x se ingresa el vector y el parámetro decreasing sirva para indicar si el ordenamiento es de menor mayor (por defecto es este) o de mayor menor.","code":"\nsort(x, decreasing = FALSE)\nrank(x)"},{"path":"funbasicas.html","id":"ejemplo-14","chapter":"8 Funciones básicas de R","heading":"Ejemplo","text":"Considere el vector x que tiene los siguientes elementos: 2, 3, 6, 4, 9 y 5. Ordene el vector de menor mayor, de mayor menor y por último encuentre la posición que ocupan los elementos de x si se ordenaran de menor mayor.","code":"\nx <- c(2, 3, 6, 4, 9, 5)\nsort(x)\n## [1] 2 3 4 5 6 9\n\nsort(x, decreasing = TRUE)\n## [1] 9 6 5 4 3 2\n\nrank(x)\n## [1] 1 2 5 3 6 4"},{"path":"funbasicas.html","id":"data-sets","chapter":"8 Funciones básicas de R","heading":"8.12 Data sets","text":"R Datasets PackagesEn R hay unas bases de datos incluídas, una de ellas es la base de datos llamada mtcars. Para conocer las variables que están en mtcars usted puede escribir en la consola ?mtcars o también help(mtcars). De la base mtcars obtenga bases de datos que cumplan las siguientes condiciones.2# FuncionesLas funciones son fragmentos de código los que se les da un nombre para que puedan usarse fácilmente varias veces. ¡Quizás sin darte cuenta, ya usado funciones muchas veces!","code":""},{"path":"funbasicas.html","id":"definición-de-la-propia-función","chapter":"8 Funciones básicas de R","heading":"8.13 Definición de la propia función","text":"Una función se compone de los siguientes elementos:un nombre: en R las funciones son objetos como vectores o matrices y se les da un nombre.un nombre: en R las funciones son objetos como vectores o matrices y se les da un nombre.argumentos: estos son objetos que se utilizarán dentro de la función.argumentos: estos son objetos que se utilizarán dentro de la función.cuerpo: un fragmento de código que se ejecuta dentro de la función.cuerpo: un fragmento de código que se ejecuta dentro de la función.salida: un objeto que devuelve la función.salida: un objeto que devuelve la función.Consideremos un ejemplo sencillo.La función anterior calcula la suma de dos números x y y. Llamémoslo.Veamos el código línea por línea.\n- En la primera línea, asignamos una función usando el comando function() un objeto llamado .function.\n- .function tiene dos argumentos llamados x y y.\n- Luego hay un corchete de apertura { y la última línea de código tiene un corchete de cierre }: lo que esté entre los dos corchetes es un fragmento de código que se ejecuta cuando se ejecuta la función.\n- La segunda línea calcula una nueva variable llamada z que almacena la suma de x y y.\n- La tercera línea de código nos dice que la función debería regresar zcomo salida.Consideremos la función.También se pueden almacenar los resultados en el enviroment de R, para futuros cálculos.También si se conocen todos los argumentos dentro las funciones de las paqueterías o creadas por otro usuario. Es necesario ser explicito en la entrada de los parametros, ya que muchas veces el orden influye en alguna funciones.Las dos formas de especificar entradas dan exactamente los mismos resultados.","code":"\nmy.function <- function(x,y){\n                  z <- x + y\n                  return(z)\n}\nmy.function(2,3)\n## [1] 5\nnew.function <- function(x,y){\n  z1 <- x^2\n  z2 <- z1 + y\n  return(z2)\n}\nnew.function(2,3)\n## [1] 7\n\nnew.function(3,2)\n## [1] 11\nvalue <- new.function(2,3)\nvalue\n## [1] 7\nnew.function(x = 2, y = 3)\n## [1] 7"},{"path":"loops.html","id":"loops","chapter":"9 Loops","heading":"9 Loops","text":"En R se disponen de varias instrucciones de control para facilitar los procedimientos que un usuario debe realizar. continuación se explican esas instrucciones de control.","code":""},{"path":"loops.html","id":"instrucción-if","chapter":"9 Loops","heading":"9.1 Instrucción if","text":"Esta instrucción sirve para realizar un conjunto de operaciones si se cumple cierta condición. continuación se muestra la estructura básica de uso.","code":"if (condicion) {\n  operación 1\n  operación 2\n  ...\n  operación final\n}"},{"path":"loops.html","id":"ejemplo-15","chapter":"9 Loops","heading":"Ejemplo","text":"Una secretaria recibe la información del salario básico semanal de un empleado y las horas trabajadas durante la semana por ese empleado. El salario básico es la remuneración por 40 horas de labor por semana, las horas extra son pagadas ciencuenta mil pesos. Se escibe el procedimiento en R que debe usar la secretaria para calcular el salario semanal de un empleado que trabajó 45 horas y tiene salario básico de un millon de pesos.El código para calcular el salario final del empleado es el siguiente:","code":"\nsal <- 1  # Salario básico por semana\nhlab <- 45   # Horas laboradas por semana\nif(hlab > 40) {\n  hext <- hlab - 40\n  salext <- hext * 0.05\n  sal <- sal + salext\n}\nsal  # Salario semanal## [1] 1.25"},{"path":"loops.html","id":"instrucción-if-else","chapter":"9 Loops","heading":"9.2 Instrucción if else","text":"Esta instrucción sirve para realizar un conjunto de operaciones cuando se cumple cierta condición evaluada por un . continuación se muestra la estructura básica de uso.","code":"\nif(condition){true_action}\nif(condition){true_action} else {false_action}if (condicion) {\n  operación 1\n  operación 2\n  ...\n  operación final\n}\nelse {\n  operación 1\n  operación 2\n  ...\n  operación final\n}"},{"path":"loops.html","id":"instrucción-ifelse","chapter":"9 Loops","heading":"9.3 Instrucción ifelse","text":"Se recomienda usar la instrucción ifelse cuando hay una sola instrucción para el caso y para el caso else. continuación se muestra la estructura básica de uso.","code":"ifelse(condición, operación SI cumple, operación NO cumple)"},{"path":"loops.html","id":"ejemplo-16","chapter":"9 Loops","heading":"Ejemplo","text":"Se supone que recibe un vector de números enteros, Se escibe un procedimiento que diga si cada elemento del vector es par o impar.","code":"\nx <- c(5, 3, 2, 8, -4, 1)\nifelse(x %% 2 == 0, 'Es par', 'Es impar')## [1] \"Es impar\" \"Es impar\" \"Es par\"   \"Es par\"   \"Es par\"   \"Es impar\""},{"path":"loops.html","id":"instrucción-for","chapter":"9 Loops","heading":"9.4 Instrucción for","text":"La instrucción es muy útil para repetir un procedimiento cierta cantidad de veces. continuación se muestra la estructura básica de uso.","code":"for (i in secuencia) {\n  operación 1\n  operación 2\n  ...\n  operación final\n}"},{"path":"loops.html","id":"ejemplo-17","chapter":"9 Loops","heading":"Ejemplo","text":"Se escibe un procedimiento para crear 10 muestras de tamaño 100 de una distribución uniforme entre uno y tres. Para cada una de las muestra, se debe contar el número de elementos de la muestra que fueron mayores o iguales 2.5.","code":"\nnrep <- 10  # Número de repeticiones\nn <- 100    # Tamaño de la muestra\nconteo <- numeric(nrep)  # Vector para almacenar el conteo\nfor (i in 1:nrep) {\n  x <- runif(n=n, min=1, max=3)\n  conteo[i] <- sum(x >= 2.5)\n}\nconteo  # Para obtener el conteo\n##  [1] 24 37 28 26 30 18 29 23 19 19\nfor (i in c(1,2,3)){\n  print(i)\n}\n## [1] 1\n## [1] 2\n## [1] 3"},{"path":"loops.html","id":"instrucción-while","chapter":"9 Loops","heading":"9.5 Instrucción while","text":"La instrucción es muy útil para repetir un procedimiento siempre que se cumple una condición. continuación se muestra la estructura básica de uso.","code":"while (condición) {\n  operación 1\n  operación 2\n  ...\n  operación final\n}"},{"path":"loops.html","id":"ejemplo-18","chapter":"9 Loops","heading":"Ejemplo","text":"Suponga que se lanza una moneda en la cual el resultado es cara o sello. Escribir un procedimiento que simule lanzamientos hasta que el número de caras obtenidas sea 5. El procedimiento debe entregar el historial de lanzamientos.Para simular el lanzamiento de una moneda se puede usar la función sample y definiendo el vector resultados con size = 1 para simular un lanzamiento, continuación el código y tres pruebas ilustrativas.Una vez seamos capaces de simular un lanzamiento podemos escribir el procedimiento para generar tantos lanzamientos hasta que se cumpla la condición. El código mostrado abajo permite hacer lo solicitado.","code":"\nresultados <- c('Cara', 'Sello')\nsample(x = resultados, size = 1)  # Prueba 1## [1] \"Sello\"\nnum.lanza <- 0     # Contador de lanzamientos\nnum.caras <- 0     # Contados de caras obtenidas\nhistorial <- NULL  # Vector vacío para almacenar\nwhile (num.caras < 5) {\n  res <- sample(x = resultados, size = 1)\n  num.lanza <- num.lanza + 1\n  historial[num.lanza] <- res\n  if (res == 'Cara') {\n    num.caras <- num.caras + 1\n  }\n}\nhistorial\n##  [1] \"Sello\" \"Sello\" \"Sello\" \"Sello\" \"Cara\"  \"Cara\"  \"Sello\" \"Sello\" \"Cara\"  \"Cara\"  \"Cara\"\nnum.lanza\n## [1] 11"},{"path":"loops.html","id":"instrucción-repeat","chapter":"9 Loops","heading":"9.6 Instrucción repeat","text":"La instrucción es muy útil para repetir un procedimiento siempre que se cumple una condición. continuación se muestra la estructura básica de uso.","code":"repeat {\n  operación 1\n  operación 2\n  ...\n  operación final\n  if (condición) break\n}"},{"path":"loops.html","id":"ejemplo-19","chapter":"9 Loops","heading":"Ejemplo","text":"Se hace un procedimiento para ir aumentando de uno en uno el valor de x hasta que x sea igual siete El procedimiento debe imprimir por pantalla la secuencia de valores de x.","code":"\nx <- 3  # Valor de inicio\nrepeat {\n   print(x)\n   x <-  x + 1\n   if (x == 8) {\n     break\n   }\n}## [1] 3\n## [1] 4\n## [1] 5\n## [1] 6\n## [1] 7"},{"path":"apply-family.html","id":"apply-family","chapter":"10 Apply family","heading":"10 Apply family","text":"La familia apply en R es un paquete integrado la base de R que permite evitar los bucles al explorar y analizar datos. La aplicación de estas funciones son increíblemente realmente útiles para trabajar con datos en R, además de que simplifican en trabajo.La estructura de esta función es la siguiente.Las apicaciones de las funciones de la familia son:-lapply() : recorre una lista y aplica una función cada elemento de esa lista (lapply devuelve una lista).\n-sapply() : una versión de lapply que simplifica los resultados (sapply devuelve un vector o matriz si es posible).\n-apply(): recorre los márgenes (filas o columnas) de una matriz, útil para tomar resúmenes de matrices o matrices de mayor dimensión.\n-tapply() : abreviatura de “aplicación de tabla”. Aplica una función sobre subconjuntos de un vector.","code":"\napply(X, MARGIN, FUN)"},{"path":"apply-family.html","id":"apply","chapter":"10 Apply family","heading":"10.1 Apply:","text":"La función apply() tiene tres argumentos:X: Una matriz o un objeto que pueda coercionarse una matriz, generalmente, un data frame.X: Una matriz o un objeto que pueda coercionarse una matriz, generalmente, un data frame.MARGIN: La dimensión (margen) que agrupará los elementos de la matriz X, para aplicarles una función.MARGIN: La dimensión (margen) que agrupará los elementos de la matriz X, para aplicarles una función.Son identificadas con números,\n1 son renglones y,\n2 son colummnas.\nSon identificadas con números,1 son renglones y,2 son colummnas.FUN: La función que aplicaremos la matriz X en su dimensión MARGIN.FUN: La función que aplicaremos la matriz X en su dimensión MARGIN.","code":""},{"path":"apply-family.html","id":"ejemplo-20","chapter":"10 Apply family","heading":"Ejemplo","text":"Por ejemplo, podemos usar apply() para obtener la sumatoria de los elementos de una matriz, por renglón.Se crea una matriz de cuatro renglones.Se aplica la función apply(), usando la función sum() en el argumento FUN, nota que sólo necesitamos el nombre de la función, sin paréntesis.Por último, damos el argumento MARGIN = 1, para aplicar la función por renglón.Esto es equivalente hacer lo siguiente.Si cambiamos el argumento MARGIN de MARGIN = 1 MARGIN = 2, entonces la función se aplicará por columna.En este caso, la función sum() ha sido aplicado cada elementos de nuestra matriz, los elementos son las columnas, y ahora cada columna es un vector.","code":"\nmatriz <- matrix(1:16, nrow = 4, ncol = 4) \napply(X = matriz, MARGIN = 1, FUN = sum)\n## [1] 28 32 36 40\nsum(matriz[1, ])\n## [1] 28\nfor(i in 1:4){\n  print(sum(matriz[i,]))\n}\n## [1] 28\n## [1] 32\n## [1] 36\n## [1] 40\napply(X = matriz, MARGIN = 2, FUN = sum)\n## [1] 10 26 42 58"},{"path":"apply-family.html","id":"fun","chapter":"10 Apply family","heading":"10.1.1 FUN","text":"El parametro FUN es un argumento que nos pide el nombre de una función que se se aplicarla todos los elementos de nuestra matriz. Algunas de las funciones mayormente usadas son:mean()sum()sd()max()min()quantile()¿Qué pasa si deseamos utilizar los demás argumentos de una función con apply? En los casos en los que una función tiene más de un argumento, asignamos los valores de estos del nombre de la función, separados por comas, usando sus propios nombres (este procedimiento es al que se refiere el argumento ... descrito en la documentación de apply). ?applySi además deseamos que el resultado aparezca sin nombres, entonces definimos el valor del argumento names de la misma manera.De este modo es posible aplicar funciones complejas que aceptan múltiples argumentos, con la ventaja que usamos pocas líneas de código.","code":"\napply(X = matriz, MARGIN = 2, FUN = quantile, probs = c(.33, .66))\n##     [,1] [,2]  [,3]  [,4]\n## 33% 1.99 5.99  9.99 13.99\n## 66% 2.98 6.98 10.98 14.98\napply(matriz, 2, quantile, probs = c(.33, .66), names = FALSE)\n##      [,1] [,2]  [,3]  [,4]\n## [1,] 1.99 5.99  9.99 13.99\n## [2,] 2.98 6.98 10.98 14.98"},{"path":"apply-family.html","id":"sappy","chapter":"10 Apply family","heading":"10.2 Sappy","text":"La función sapply() en R es una función integrada que aplica una función todos los elementos de entrada. El método sapply() toma una lista, un vector o un data.frame como argumento y devuelve un vector o una matriz.Para usar la función sapply() en R, se deberá especificar la lista o el vector sobre el que desea iterar en el primer argumento y la función que desea aplicar cada elemento del vector en el segundo.Teniendo en cuenta que se puede usar una función de cualquier paquetería|repositorio o bien puede ser función personalizada :La tercera función es más compleja de realizar, pero es importante tomar en cuenta que se puede aplicar cualquier función que uno desee.Consideramos, por ejemplo, que se desea calcular el cuadrado de los elementos de un vector. Usando la función ().Sin embargo, con la función sapply() se puede escribir todo en una sola línea de código para obtener el mismo resultado:","code":"\nsapply(X, FUN, ..., simplify = TRUE, USE.NAMES = TRUE)\nsapply(1:4, sqrt) \n## [1] 1.000000 1.414214 1.732051 2.000000\n\n# Es equivalente a:\nsapply(1:4, function(i) sqrt(i))  \n## [1] 1.000000 1.414214 1.732051 2.000000\n\n# También es equivalente a: \n# Also equivalent to:\nmy_fun <- function(i) {\n    sqrt(i)\n}\n\nsapply(1:4, my_fun) \n## [1] 1.000000 1.414214 1.732051 2.000000\nout <- numeric(10)\n\nfor (i in 1:10) {\n    out[i] <- i ^ 2\n}\nout\n##  [1]   1   4   9  16  25  36  49  64  81 100\nsapply(1:10, function(i) i ^ 2)\n##  [1]   1   4   9  16  25  36  49  64  81 100"},{"path":"apply-family.html","id":"ejemplo-21","chapter":"10 Apply family","heading":"Ejemplo","text":"Si se tiene una lista en lugar de un vector, los pasos son análogos, pero se tiene en cuenta que la función se aplicará los elementos de la lista. En el siguiente ejemplo se cálcula el número de componentes de cada elemento de la lista con la función length().La función sapply en R permite usar argumentos adicionales la función que está aplicando después de la función usar. Se considera una lista con valor NA:Si se aplica la función sum cada elemento de la lista, devolverá la suma de los componentes de cada elemento, pero como el segundo elemento contiene un valor NA, la suma también devuelve un valor NA.Como la función sum tiene un argumento adicional llamado na.rm, se puede configurarlo la siguiente manera para eliminar los valores NA. Véase ?sum.En consecuencia, el valor NA se tiene en cuenta y la función devuelve la suma de los valores finitos.","code":"\nList <- list(A = 1:5, B = 6:20, C = 1)\n\nsapply(List, length)\n##  A  B  C \n##  5 15  1\nmy_list <- list(A = c(1, 4, 6), B = c(8, NA, 9 , 5))\nsapply(my_list, sum)\n##  A  B \n## 11 NA\nsapply(my_list, sum, na.rm = TRUE)\n##  A  B \n## 11 22"},{"path":"apply-family.html","id":"lapply","chapter":"10 Apply family","heading":"10.3 Lapply","text":"La función lapply() es un caso especial de apply(), diseñado para aplicar funciones todos los elementos de una lista. La l de su nombre se refiere, precisamente, lista.Esta función intentará coercionar una lista el objeto que demos como argumento y después aplicará una función todos sus elementos.La estructura de esta función es:En donde:X es una lista o un objeto coercionable una lista.FUN es la función aplicar.","code":"\nlapply(X, FUN)\nlapply(c(3, 5, 7), exp)\n## [[1]]\n## [1] 20.08554\n## \n## [[2]]\n## [1] 148.4132\n## \n## [[3]]\n## [1] 1096.633\n\n# Se puede expresar de esta manera\nlapply(1:5, function(i) exp(i))\n## [[1]]\n## [1] 2.718282\n## \n## [[2]]\n## [1] 7.389056\n## \n## [[3]]\n## [1] 20.08554\n## \n## [[4]]\n## [1] 54.59815\n## \n## [[5]]\n## [1] 148.4132"},{"path":"apply-family.html","id":"sapply-vs-lapply","chapter":"10 Apply family","heading":"10.4 sapply vs lapply","text":"La diferencia entre las funciones lapply y sapply es el tipo de resultado que arroja cada función:sapply \\(\\rightarrow\\) vector,lapply \\(\\rightarrow\\) lista.En ambos casos depende mucho el contexto en el que se use una función u otra, alguna veces es mejor trabajar con listas cuando se intenta hacer manipulación de datos data mining y guardar los resultados en listas.\nSi se considera que se quiere calcular la exponencial de tres números. Como primer caso, si usa la función sapply, se obtendrá un vector como salida. O bien, si se usa la función lapply, se obtendrá una lista donde cada elemento corresponde los componentes del vector anterior.Sin embargo, por un lado, si establece el argumento simplify = FALSE dentro de la función sapply obtendrá el mismo resultado que la función lapply. Teniendo en cuenta que esto es lo mismo que usar la función .list():Por otro lado, se puede convertir la salida de la función lapply al mismo tipo de salida de la función sapply con las funciones simplify2array o unlist():En resumen, las funciones sapply y lapply son casi iguales, pero difieren en la clase de salida.","code":"\nsapply(c(3, 5, 7), exp)\n## [1]   20.08554  148.41316 1096.63316\n\nlapply(c(3, 5, 7), exp)\n## [[1]]\n## [1] 20.08554\n## \n## [[2]]\n## [1] 148.4132\n## \n## [[3]]\n## [1] 1096.633\nsapply(c(3, 5, 7), exp, simplify = FALSE)\n## [[1]]\n## [1] 20.08554\n## \n## [[2]]\n## [1] 148.4132\n## \n## [[3]]\n## [1] 1096.633\n\nas.list(sapply(c(3, 5, 7), exp)) # Equivalent\n## [[1]]\n## [1] 20.08554\n## \n## [[2]]\n## [1] 148.4132\n## \n## [[3]]\n## [1] 1096.633\nsimplify2array(lapply(c(3, 5, 7), exp))\n## [1]   20.08554  148.41316 1096.63316\n\n\nunlist(lapply(c(3, 5, 7), exp)) # Equivalent\n## [1]   20.08554  148.41316 1096.63316"},{"path":"directorio-de-trabajo.html","id":"directorio-de-trabajo","chapter":"11 Directorio de trabajo","heading":"11 Directorio de trabajo","text":"El directorio o carpeta de trabajo es el lugar en nuestra computadora en el que se encuentran los archivos con los que estamos trabajando en R. Este es el lugar donde R buscara archivos para importarlos y al que serán exportados, menos que indiquemos otra cosa.Se puede encontrar cuál es el directorio de trabajo con la función getwd(). Sólo tienes que escribir la función en la consola y ejecutarla.Se mostrará en la consola la ruta del directorio que se está usando R.Se puede cambiar el directorio de trabajo usando la función setwd(), dando como argumento la ruta del directorio que quieres usar.Nota.- Cuando se esta trabajando con un proyecto R con subcarpetas anidadas, de modo que los archivos .Rproj y .Rmd están ubicados en carpetas diferentes, se pueden usar el comando rprojroot::find_rstudio_root_file() para buscar y establecer el directorio de trabajo en la carpeta principal del proyecto durante la creación de knits (en lugar de la carpeta que contiene el archivo de código RMarkdown).Entonces, como mínimo, se usa lo siguiente:Este commando debe ir siempre al inicio del setup chunk de los archivos RMarkdown para reposicionar el directorio de trabajo.TambiénPor último, si deseas conocer el contenido de tu directorio de trabajo, se puede ejecutar. la función list.files(), sin argumentos, que devolverá una lista con el nombre de los archivos de tu directorio de trabajo. La función list.dirs(), también sin argumentos` dará una lista de los directorios dentro del directorio de trabajo.","code":"\ngetwd()setwd(\"C:\\otro_directorio\")\nknitr::opts_knit$set(root.dir =  \"C:/otro_directorio\")\nknitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())\nknitr::opts_knit$set(root.dir = here::here())\n# Ver archivos\nlist.files()\n# Ver directorios\nlist.dirs()"},{"path":"directorio-de-trabajo.html","id":"sesión","chapter":"11 Directorio de trabajo","heading":"11.0.1 Sesión","text":"Los objetos y funciones de R son almacenados en la memoria RAM de nuestra computadora.Cuando ejecutamos R, ya sea directamente o través de RStudio, estamos creando una instancia del entorno del entorno computacional de este lenguaje de programación. cada instancia es una sesión.Todos los objetos y funciones creadas en una sesión, permanecen sólo en ella, son compartidos entre sesiones, sin embargo una sesión puede tener el mismo directorio de trabajo que otra sesión. Es posible tener más de una sesión de R activa en la misma computadora.Cuando cerramos R, también cerramos nuestra sesión. Se nos preguntará si deseamos guardar el contenido de nuestra sesión para poder volver ella después. Esto se guarda en un archivo con extensión **.Rdata* en el directorio de trabajo.Para conocer los objetos y funciones que contiene nuestra sesión, usamos la función ls(), que nos devolverá una lista con los nombres de todo lo guardado en la sesión.De manera más precisa, la sesión es un entorno de trabajo y los objetos pertenecen un entorno específico. Los entornos son un concepto importante al hablar de lenguajes de programación.Con que recuerdes que cada sesión de R tiene su propio entorno global, eso será suficiente.","code":"\nls()##  [1] \"a\"                  \"age\"                \"angulos\"            \"ans\"                \"b\"                 \n##  [6] \"bcancer\"            \"chic.f\"             \"chicago\"            \"comic_fav\"          \"conteo\"            \n## [11] \"deporte\"            \"df\"                 \"dt1\"                \"dt2\"                \"edad\"              \n## [16] \"factor_cinco\"       \"hext\"               \"historial\"          \"hlab\"               \"i\"                 \n## [21] \"iris_csv\"           \"iris_excel\"         \"iris_txt\"           \"List\"               \"lista_recursiva\"   \n## [26] \"matriz\"             \"matriz_t\"           \"matriz2\"            \"mi_df\"              \"mi_lista\"          \n## [31] \"mi_lista_importado\" \"mi_matriz\"          \"mi_vector\"          \"mi_vector_1\"        \"mi_vector_2\"       \n## [36] \"mi_vector_3\"        \"mi_vector_mezcla\"   \"mi_vector_nuevo\"    \"miarray\"            \"milista\"           \n## [41] \"mimarco\"            \"mimatriz\"           \"mivector\"           \"my.function\"        \"my_fun\"            \n## [46] \"my_list\"            \"myvec\"              \"n\"                  \"new.function\"       \"nombres\"           \n## [51] \"notas\"              \"nrep\"               \"num.caras\"          \"num.lanza\"          \"out\"               \n## [56] \"pais\"               \"qq\"                 \"quint\"              \"res\"                \"resultados\"        \n## [61] \"sal\"                \"salext\"             \"subset\"             \"trees_excel\"        \"url\"               \n## [66] \"value\"              \"vec\"                \"vector_1\"           \"vector_2\"           \"vector_3\"          \n## [71] \"vector_4\"           \"x\"                  \"y\"                  \"years\""},{"path":"directorio-de-trabajo.html","id":"paquetes","chapter":"11 Directorio de trabajo","heading":"11.1 Paquetes","text":"R puede ser expandido con paquetes. Cada paquete es una colección de funciones diseñadas para atender una tarea específica. Por ejemplo, hay paquetes para trabajo visualización geoespacial, análisis psicométricos, minería de datos, interacción con servicios de Internet y muchas otras cosas más.Estos paquetes se encuentran alojados en CRAN, así que pasan por un control riguroso antes de estar disponibles para su uso generalizado.Podemos instalar paquetes usando la función install.packages(), dando como argumento el nombre del paquete que deseamos instalar, entre comillas.Por ejemplo, para instalar el paquete readr, corremos lo siguiente.Hecho esto, aparecerán algunos mensajes en la consola mostrando el avance de la instalaciónUna vez concluida la instalación de un paquete, podrás usar sus funciones con la función library(). Sólo tienes que llamar esta función usando como argumento el nombre del paquete que quieres utilizarCuando haces esto, R importa las funciones contenidas en el paquete al entorno de trabajo actual.Es importante que se tenga en mente que se deben hacer una llamada library() cada que se inicien en una sesión en R. Aunque se hayan importado las funciones de un paquete con anterioridad, las sesiones de R se inician “limpias”, sólo con los objetos y funciones de base.Este comportamiento es para evitar problemas de compatibilidad y para propiciar buenas prácticas de colaboración.Si se importan paquetes automáticamente y se usan sus funciones sin indicar de donde provienen, al compartir nuestro código con otras personas, estas tendrán la información completa para entender qué estamos haciendo. R, al pedirnos que cada sesión indiquemos qué estamos importando, nos obliga ser explícito con todo lo que estamos haciendo. Es un poco latoso, pero te acostumbras ello.En caso de escribir en install.packages() el nombre de un paquete disponible en CRAN, se nos mostrará una advertencia y se instalará nada.Los paquetes que se han en nuestra sesión actual aparecen al llamar sessionInfo().También se puede ver qué paquetes se tienen ya instalados ejecutando la función installed.packages() sin ningún argumento. Una instalación nueva de R tiene pocos paquetes instalados, pero esta lista puede crecer considerablemente con el tiempo.","code":"\ninstall.packages(\"readr\")\nlibrary(readr) \nrequire(readr)\ninstall.packages(\"un_paquete_falso\")\nsessionInfo()"},{"path":"directorio-de-trabajo.html","id":"scripts","chapter":"11 Directorio de trabajo","heading":"11.2 Scripts","text":"Los scripts son documentos de texto con la extensión de archivo .R, por ejemplo mi_script.R.Estos archivos son iguales cualquier documentos de texto, pero R los puede leer y ejecutar el código que contienen.Aunque R permite el uso interactivo, es recomendable que se guarden el código en un archivo .R, de esta manera se puede usarlo después y compartirlo con otras personas. En realidad, en proyectos complejos, es posible que sean necesarios múltiples scripts para distintos fines.Se pueden abrir y ejecutar scripts en R usando la función source(), dándole como argumento la ruta del archivo .R en la computadora, entre comillas.Por ejemplo.","code":"\nsource(\"C:/Mis scripts/mi_script.R\")"},{"path":"importar-y-exportar-datos.html","id":"importar-y-exportar-datos","chapter":"12 Importar y exportar datos","heading":"12 Importar y exportar datos","text":"Hasta ahora, se han trabajado con datos ya existentes en R base o que se han generado por de manera autónoma, sin embargo, lo usual es que se usen datos almacenados en archivos fuera de R.R puede importar datos de una amplia variedad de tipos de archivo con las funciones base además de que esta capacidad es ampliada con el uso de paquetes específicos.Cuando se importa un archivo, se están guardando su contenido en la sesión como un objeto. Dependiendo del procedimiento que se usen será el tipo de objeto creado.De manera análoga, se pueden exportar los objetos de R archivos dentro de la computadora.","code":""},{"path":"importar-y-exportar-datos.html","id":"descargando-datos","chapter":"12 Importar y exportar datos","heading":"12.1 Descargando datos","text":"Antes de empezar importar datos, vale la pena señalar que se pueden descargar archivos de internet usando R con la función download.file().De esta manera se tendrpa acceso una vasta diversidad de fuentes de datos. Entre otras, se podrán descargar los archivos.La función download.file() pide como argumento url, la dirección de internet del archivo que se quiere descargar y destfile el nombre que tendrá el archivo en la computadora. Ambos argumentos como cadenas de texto, es decir, entre comillas.Por ejemplo, para descargar una copia del set iris disponible en el UCI Machine Learning Repository se usa la siguiente dirección como argumento url:https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.dataY se asigna “iris.data” al argumento dest.El resultado es un archivo llamado “iris.data” en el directorio de trabajo y dentro de la carpeta “Bases”.Este método funciona con prácticamente todo tipo de archivos, aunque en algunos casos será necesario agregar el argumento method = \"wb\", por asegurar que el archivo obtenido funcione correctamente.","code":"\ndownload.file(\n  url = \"https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data\", \n  destfile = \"Bases/iris.data\"\n  )"},{"path":"importar-y-exportar-datos.html","id":"tablas-datos-rectangulares","chapter":"12 Importar y exportar datos","heading":"12.2 Tablas (datos rectangulares)","text":"La estructura rectangular, en renglones y columnas, es común y conveniente para el análisis de datos. Se refiere esta forma de organizar datos como tabla. R cuenta con la función genérica read.table(), que puede leer cualquier tipo de archivo que contenga una tabla.La condición para que R interprete un archivo como una tabla es que tenga renglones y en cada renglón, los datos estén separados por comas, o algún otro carácter, indicando columnas. Es decir, algo que luzca de la siguiente manera.1, 20, 8, 5\n1, 31, 6, 5\n2, 18, 9, 5\n2, 25, 10, 5Por supuesto, en lugar de comas se pueden tener puntos y coma, dos puntos, tabuladores o cualquier otro signo de puntuación como separador de columnas.La función read.table() acepta un número considerable de argumentos. Los más importantes son los siguientes.file: La ruta del archivo que se importa, como cadena de texto. Si el archivo se encuentra en el directorio de trabajo, es suficiente dar el nombre del archivo, sin la ruta completa.header: Si el archivo tiene encabezados, para ser interpretados como nombres de columna, se define este argumento como TRUE.sep: El carácter que es usado como separador de columnas. Por defecto es “;”.col.names: Un vector opcional, de tipo carácter, con los nombres de las columnas en la tabla.stringsAsFactors: Esta función convierte automáticamente los datos de texto factores. Si este es el comportamiento que se desea, se define este argumento como FALSE.Se pueden consultar todos los argumentos de esta función ejecutando ?read.table en la consola.Es importante señalar que el objeto obtenido al usar esta función es siempre un data frame.Ejemplo, con un archivo con extensión “.data”, descargado desde el repositorio de Machine Learning Repository.Estos datos pertenecen una base de diagnósticos de cáncer mamario de la Universidad de Wisconsin, usado para probar métodos de aprendizaje automático. Se puede encontrar la información completa sobre este conjunto de datos en el siguiente enlace:https://archive.ics.uci.edu/ml/datasets/Breast+Cancer+Wisconsin+%28Diagnostic%29\nSe usa sin especificar ningún otro argumento.Veamos los primeros renglones de la base de datos usando la función head()Los datos lucen particularmente bien. Se necesitan ajustar algunos parámetros al importarlos.hay datos de encabezado, por lo que header será igual FALSE y el separador de columnas es una coma, así que el valor de sep será “,”. se conoce cuál es el nombre de las columnas, así que por el momento se proporcionan uno.Los nombres de las columnas son poco descriptivos. Si damos nombres de variables, cada columna tendrá como nombre “V” seguida de números del 1 adelante.Para este ejemplo, se cuenta con un archivo de información, que describe el contenido de los datos que se han importado.https://archive.ics.uci.edu/ml/machine-learning-databases/breast-cancer-wisconsin/breast-cancer-wisconsin.namesSi descargas este archivo, se puede abrirlo usando el bloc o navegador de internet de la computadora.Se guargan en un vector las abreviaturas de los nombres de columna descritos en el documento anterior.Ahora se usa este vector como argumento col.names en read.table(), para importar els datos con nombres de columna.La base de datos ha sido importada correctamente. Además, el objeto resultante es un data frame.","code":"\ndownload.file(\n  url = \"https://archive.ics.uci.edu/ml/machine-learning-databases/breast-cancer-wisconsin/breast-cancer-wisconsin.data\", \n  dest = \"Bases/breast-cancer-wis.data\"\n)\nbcancer <- read.table(file = \"Bases/breast-cancer-wis.data\")\nhead(bcancer)\n##                               V1\n## 1    1000025,5,1,1,1,2,1,3,1,1,2\n## 2   1002945,5,4,4,5,7,10,3,2,1,2\n## 3    1015425,3,1,1,1,2,2,3,1,1,2\n## 4    1016277,6,8,8,1,3,4,3,7,1,2\n## 5    1017023,4,1,1,3,2,1,3,1,1,2\n## 6 1017122,8,10,10,8,7,10,9,7,1,4\nbcancer <- read.table(file = \"Bases/breast-cancer-wis.data\", header = FALSE, sep = \",\")\n# Resultado\nhead(bcancer)\n##        V1 V2 V3 V4 V5 V6 V7 V8 V9 V10 V11\n## 1 1000025  5  1  1  1  2  1  3  1   1   2\n## 2 1002945  5  4  4  5  7 10  3  2   1   2\n## 3 1015425  3  1  1  1  2  2  3  1   1   2\n## 4 1016277  6  8  8  1  3  4  3  7   1   2\n## 5 1017023  4  1  1  3  2  1  3  1   1   2\n## 6 1017122  8 10 10  8  7 10  9  7   1   4\nnombres <- c(\"id\", \"clump_t\", \"u_csize\", \"u_cshape\", \"m_adh\", \"spcs\", \"b_nuc\", \n             \"b_chr\", \"n_nuc\", \"mit\", \"class\")\nbcancer <- read.table(file = \"Bases/breast-cancer-wis.data\", header = FALSE, sep = \",\",\n                       col.names = nombres)\n# Resultado\nhead(bcancer)\n##        id clump_t u_csize u_cshape m_adh spcs b_nuc b_chr n_nuc mit class\n## 1 1000025       5       1        1     1    2     1     3     1   1     2\n## 2 1002945       5       4        4     5    7    10     3     2   1     2\n## 3 1015425       3       1        1     1    2     2     3     1   1     2\n## 4 1016277       6       8        8     1    3     4     3     7   1     2\n## 5 1017023       4       1        1     3    2     1     3     1   1     2\n## 6 1017122       8      10       10     8    7    10     9     7   1     4\nclass(bcancer)\n## [1] \"data.frame\"\n\nstr(bcancer)\n## 'data.frame':    699 obs. of  11 variables:\n##  $ id      : int  1000025 1002945 1015425 1016277 1017023 1017122 1018099 1018561 1033078 1033078 ...\n##  $ clump_t : int  5 5 3 6 4 8 1 2 2 4 ...\n##  $ u_csize : int  1 4 1 8 1 10 1 1 1 2 ...\n##  $ u_cshape: int  1 4 1 8 1 10 1 2 1 1 ...\n##  $ m_adh   : int  1 5 1 1 3 8 1 1 1 1 ...\n##  $ spcs    : int  2 7 2 3 2 7 2 2 2 2 ...\n##  $ b_nuc   : chr  \"1\" \"10\" \"2\" \"4\" ...\n##  $ b_chr   : int  3 3 3 3 3 9 3 3 1 2 ...\n##  $ n_nuc   : int  1 2 1 7 1 7 1 1 1 1 ...\n##  $ mit     : int  1 1 1 1 1 1 1 1 5 1 ...\n##  $ class   : int  2 2 2 2 2 4 2 2 2 2 ..."},{"path":"importar-y-exportar-datos.html","id":"archivos-csv","chapter":"12 Importar y exportar datos","heading":"12.2.1 Archivos CSV","text":"Un caso particular de las tablas, son los archivos separados por comas, con extensión .csv, por Comma Separated Values, sus siglas en inglés. Este es un tipo de archivo comúnmente son usados para compartir datos, pues es compatible con una amplia variedad de sistemas diferentes además de que ocupa relativamente poco espacio de almacenamiento.Este tipo de archivos también se pueden importar usando la función read.table().Se prueba descargando los mismos datos que en el ejemplo anterior, pero almacenados en un archivo con extensión .csv.Se puede usar read.table() con los mismos argumentos que en el ejemplo anterior, con la excepción de que este archivo sí tiene encabezados de columna, por lo que cambiamos header de FALSE TRUE.Una ventaja de usar documentos con extensión .csv es la posibilidad de usar la función read.csv(). Esta es una es una versión de read.table(), optimizada para importar archivos .csv.read.csv() acepta los mismos argumentos que read.table(), pero al usarla con un archivo .csv, en casi todo los casos, hará falta especificar nada salvo la ruta del archivo.read.csv() también devuelve un data frame como resultado.","code":"\ndownload.file(\n  url = \"https://archive.ics.uci.edu/ml/machine-learning-databases/breast-cancer-wisconsin/breast-cancer-wisconsin.data\", \n  dest = \"Bases/breast-cancer-wis.csv\"\n)\nbcancer <- read.table(file = \"Bases/breast-cancer-wis.csv\", header = TRUE, sep = \",\",\n                      col.names = nombres)\n# Resultado\nhead(bcancer)\n##        id clump_t u_csize u_cshape m_adh spcs b_nuc b_chr n_nuc mit class\n## 1 1002945       5       4        4     5    7    10     3     2   1     2\n## 2 1015425       3       1        1     1    2     2     3     1   1     2\n## 3 1016277       6       8        8     1    3     4     3     7   1     2\n## 4 1017023       4       1        1     3    2     1     3     1   1     2\n## 5 1017122       8      10       10     8    7    10     9     7   1     4\n## 6 1018099       1       1        1     1    2    10     3     1   1     2\nbcancer <- read.csv(\"Bases/breast-cancer-wis.csv\")\n# Resultado\nhead(bcancer)\n##   X1000025 X5 X1 X1.1 X1.2 X2 X1.3 X3 X1.4 X1.5 X2.1\n## 1  1002945  5  4    4    5  7   10  3    2    1    2\n## 2  1015425  3  1    1    1  2    2  3    1    1    2\n## 3  1016277  6  8    8    1  3    4  3    7    1    2\n## 4  1017023  4  1    1    3  2    1  3    1    1    2\n## 5  1017122  8 10   10    8  7   10  9    7    1    4\n## 6  1018099  1  1    1    1  2   10  3    1    1    2"},{"path":"importar-y-exportar-datos.html","id":"archivos-con-una-estructura-desconocida","chapter":"12 Importar y exportar datos","heading":"12.3 Archivos con una estructura desconocida","text":"Habrá ocasiones en las que se están seguros del contenido de los archivos que se desea importar. En estos casos, se puede pedirle R que intente abrir el archivo en cuestión, usando la función file.show().Por ejemplo, abrir el archivo con extensión .csv que se importo con anterioridad.R intentará usar el programa que en el equipo, por defecto, abre el tipo de archivo que se le ha indicado. Si tenemos un programa configurado para abrir el tipo de archivo que se desea, el sistema operativo nos pedirá que elijamos uno.Lo anterior puede ocurrir si se intenta abrir el archivo con extensión .data que se han importado en este capítulo.Se puede usar la función readLines() para leer un archivo línea por línea. Se establece el argumento n = 4 para obtener sólo los primeros cuatro renglones del documento.La salida es una lista de vectores, uno por linea en el archivo.Observando la salida de readLines() se puede determinar si el archivo de nuestro interés puede ser importado usando algunos de los métodos que se han revisado o se necesitarán de herramientas diferentes.El documento “R Data Import/Export” (R Core Team, 2018) contiene una guía avanzada sobre el proceso de importar y exportar todo tipo de datos. Puedes consultarlo en el siguiente enlace:https://cran.r-project.org/doc/manuals/r-release/R-data.pdf","code":"\nfile.show(\"Bases/breast-cancer-wis.csv\")\nfile.show(\"Bases/breast-cancer-wis.data\")\nreadLines(\"Bases/breast-cancer-wis.data\", n = 4)## [1] \"1000025,5,1,1,1,2,1,3,1,1,2\"  \"1002945,5,4,4,5,7,10,3,2,1,2\" \"1015425,3,1,1,1,2,2,3,1,1,2\" \n## [4] \"1016277,6,8,8,1,3,4,3,7,1,2\""},{"path":"importar-y-exportar-datos.html","id":"exportar-datos","chapter":"12 Importar y exportar datos","heading":"12.4 Exportar datos","text":"Un paso muy importante en el trabajo con R es exportar los datos que se han generado, ya sea para que sean usados por otras personas o para almacenar información en el disco duro en lugar de el RAM.Dependiendo del tipo de estructura de dato en el que se encuentran contenidos la base datos son las opciones que tenemos para exportarlos.","code":""},{"path":"importar-y-exportar-datos.html","id":"data-frames-y-matrices","chapter":"12 Importar y exportar datos","heading":"12.4.1 Data frames y matrices","text":"Si los datos se encuentran contenidos en una estructura de datos rectangular, se pueden exportarlos con diferentes funciones.De manera análoga read.table(), la función write.table() permite exportar matrices o data frames, como archivos de texto con distintas extensiones.Los argumentos más usados de write.table() son los siguientes.x: El nombre del data frame o matriz exportar.file: El nombre, extensión y ruta del archivo creado con esta función. Si sólo se escribe el nombre del archivo, este será creado en el directorio de trabajo.sep: El carácter que se usará como separador de columnas.row.names: Si se desea incluir el nombre de los renglones en el objeto al exportarlo, se establece este argumento como TRUE. En general, es recomendable fijarlo como FALSE, para conservar una estructura tabular más fácil de leer.col.names: Si se desea que el archivo incluya los nombres de las columnas en el objeto, se establece este argumento como TRUE. Es recomendable fijarlo como TRUE para evitar la necesidad de almacenar los nombres de columna en documentos distintos.Se pueden consultar todos los argumentos de esta función ejecutando ?write.table.Se prueba exportando el objeto iris un documento de texto llamado iris.txt el directorio de trabajo, usando como separador la coma, con nombres de columnas y sin nombre de renglones.Se importa el archivo que se han creado usando read.table().También se pueden exportar datos archivos con extensión .csv con la función write.csv().Se desea exportar iris como un documento .csv. En este caso, sólo se especifica que se desean guardar los nombres de los renglones con row.names = FALSE.Se importa el archivo creado.","code":"\nwrite.table(x = iris, file = \"Bases/iris.txt\", sep = \",\", \n            row.names = FALSE, col.names = TRUE)\niris_txt <- read.table(file = \"Bases/iris.txt\", header = TRUE, sep = \",\")\n# Resultado\nhead(iris_txt)##   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n## 1          5.1         3.5          1.4         0.2  setosa\n## 2          4.9         3.0          1.4         0.2  setosa\n## 3          4.7         3.2          1.3         0.2  setosa\n## 4          4.6         3.1          1.5         0.2  setosa\n## 5          5.0         3.6          1.4         0.2  setosa\n## 6          5.4         3.9          1.7         0.4  setosa\nwrite.csv(x = iris, file = \"Bases/iris.csv\", row.names = FALSE) \niris_csv <- read.csv(\"Bases/iris.csv\")\n# Resultado\nhead(iris_csv)##   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n## 1          5.1         3.5          1.4         0.2  setosa\n## 2          4.9         3.0          1.4         0.2  setosa\n## 3          4.7         3.2          1.3         0.2  setosa\n## 4          4.6         3.1          1.5         0.2  setosa\n## 5          5.0         3.6          1.4         0.2  setosa\n## 6          5.4         3.9          1.7         0.4  setosa"},{"path":"importar-y-exportar-datos.html","id":"listas-2","chapter":"12 Importar y exportar datos","heading":"12.4.2 Listas","text":"La manera más sencilla de exportar listas es guardarlas en archivos RDS. Este es un tipo de archivo nativo de R se puede almacenar cualquier objeto un archivo en el disco duro.Además, RDS comprime los datos que almacena, por lo que ocupa menos espacio en disco duro que otros tipos de archivos, aunque contengan la misma información.Para exportar un objeto un archivo RDS, se usa la función saveRDS() que siempre pide dos argumentos:object: El nombre del objeto exportar.file: El nombre y ruta del archivo que se crearan. Los archivos deben tener la extensión .rds. Si se especifica una ruta completa, el archivo será creado en el directorio de trabajo.Se crea una lista de ejemplo que contiene dos vectores y dos matricesAunque se pueden intentar write.table() para exportar listas, por lo general se obtiene un error como resultado.Se trata de exportar la lista anterior como un archivo .txt.Se usa la función saveRDS() para exportar al archivo mi_lista.rds.Si se desea importar un archivo RDS R, se usa la función readRDS(), indicando la ruta en la que se encuentra el archivo que se desea.Se intenta importar el archivo mi_lista.rds.El resultado de la importación:Los objetos importados usando un archivo RDS conservan los tipos y clases que tenían originalmente, lo cual previene pérdida de información.","code":"\nmi_lista <- list(\"a\" = c(TRUE, FALSE, TRUE),\n                 \"b\" = c(\"a\", \"b\", \"c\"),\n                 \"c\" = matrix(1:4, ncol = 2),\n                 \"d\" = matrix(1:6, ncol = 3))\n# Resultado\nmi_lista\n## $a\n## [1]  TRUE FALSE  TRUE\n## \n## $b\n## [1] \"a\" \"b\" \"c\"\n## \n## $c\n##      [,1] [,2]\n## [1,]    1    3\n## [2,]    2    4\n## \n## $d\n##      [,1] [,2] [,3]\n## [1,]    1    3    5\n## [2,]    2    4    6\nwrite.table(x = mi_lista, file = \"Bases/mi_lista.txt\")\n## Error in (function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, : arguments imply differing number of rows: 3, 2\nsaveRDS(object = mi_lista, file = \"Bases/mi_lista.rds\")\nmi_lista_importado <- readRDS(file = \"Bases/mi_lista.rds\")\nmi_lista_importado\n## $a\n## [1]  TRUE FALSE  TRUE\n## \n## $b\n## [1] \"a\" \"b\" \"c\"\n## \n## $c\n##      [,1] [,2]\n## [1,]    1    3\n## [2,]    2    4\n## \n## $d\n##      [,1] [,2] [,3]\n## [1,]    1    3    5\n## [2,]    2    4    6\n# El resultado es una lista, al igual que el objeto original\nclass(mi_lista)\n## [1] \"list\""},{"path":"importar-y-exportar-datos.html","id":"hojas-de-cálculo-de-excel","chapter":"12 Importar y exportar datos","heading":"12.5 Hojas de cálculo de Excel","text":"Un formato usado con mucha frecuencia para almacenar archivos son las hojas de cálculo, en particular las generadas por el paquete Microsoft Excel.R base tiene una función para importar archivos almacenados en archivos con extensión .xsl y .xslx, creados con Excel.Para importar datos desde este tipo de archivos, se necesitan instalar el paquete readxl, que contiene funciones específicas para realizar esta tarea.Ae usa la función installpackages(), en caso de que se tenga.Ya instalado, se manda llamar el paquete readxl la sesión de trabajo.Se usaran, principalmente dos funciones de este paquete.read_excel(): Para importar archivos .xls y xlsx.excel_sheets(): Para obtener los nombres de las pestañas en una hoja de cálculo de Excel.Para probar estas funciones, se descarga una hoja de cálculo de prueba. Nota que se han establecido el argumento mode = \"wb\" para asegurar que el archivo se descargue correctamente.Si se necesita leer las primeras cinco líneas de data_frames.xlsx, se confrima que este es un archivo que tiene forma rectangular, de tabla.En caso de que se tenga instalado Excel o algún otro programa compatible con archivos de hoja de cálculo, como LibreOffice Calc o Number, se pueden pedir R que abra este archivo con file.show(). De este modo se pueden explorar su contenido.La función excel_sheets() devuelve el nombre de las pestañas como un vector.Este archivo tiene dos pestañas, llamadas iris y trees.Se intentará importar la pestaña iris con read_excel(). Esta función tiene los siguientes argumentos principales.path: La ruta del archivo importar. Si se especifica una ruta completa, será buscado en el directorio de trabajo.sheet: El nombre de la pestaña importar. Si se especifica este argumento, read_excel() intentará leer la primera pestaña de la hoja de cálculo.range: Cadena de texto con el rango de celdas importar, escrito con el formato usado en Excel. Por ejemplo, “A1:B:10”.col_names: Con este argumento se indica si la pestaña que se va importar tiene encabezados para usar como nombres de columna. Por defecto su valor es TRUE. Si tenemos encabezados, se pueden dar un vector con nombres para asignar las columnas.Se puede consultar todos los argumentos de esta función ejecutando ?read_excel.Se utiliza la función read_excel(), como ejemplo:El resultado es un data frame.Si los datos en la hoja de cálculo tienen forma de tabla, read_excel() se tendrá problemas para importarlos. Cuando este es el caso, se usa el argumento range para extraer sólo la información que interesa.Se intenta importar la pestaña trees.Los resultados lucen correctamente porque los datos en la pestaña tienen forma de tabla.Se ajustan los argumentos de read_excel() para leer correctamente la información de la pestaña. Al explorar manualmente el archivo data.frames.xlsx, se pueden localizar el rango en el que se encuentran los datos (de las celdas B3 D33) y los nombres de las columnas (Girth, Height y Volume).Se prueba importar de nuevo con esta información.Esta vez se han tenido éxito y los datos importados son los correctos.El paquete readxl tiene más funciones para trabajar con hojas de cálculo además de read_excel() y excel_sheets().Se puede conocer más sobre ellas en la documentación de readxl, llamando help(package = \"readxl\").","code":"\ninstall.packages(\"readxl\")\nlibrary(readxl)\ndownload.file(\n  url = \"https://github.com/jboscomendoza/r-principiantes-bookdown/raw/master/datos/data_frames.xlsx\", \n  destfile = \"Bases/data_frames.xlsx\", \n  mode = \"wb\"\n) \nreadLines(\"Bases/data_frames.xlsx\", n = 5)## Warning in readLines(\"Bases/data_frames.xlsx\", n = 5): line 1 appears to contain an embedded nul## Warning in readLines(\"Bases/data_frames.xlsx\", n = 5): incomplete final line found on 'Bases/data_frames.xlsx'## [1] \"PK\\003\\004\\024\"                                                                                                                                                                                                           \n## [2] \"\\177߉YTU,B \\xf5\\x92(\\xb1\\xe7m\\xf6L\\177\\xb8j\\xead\\t\\001\\x8d\\xb3\\xb9\\xe8f\\035\\x91\\x80-\\x9c6v\\x96\\x8b\\xaf\\xc9{\\xfa$\\022$e\\xb5\\xaa\\x9d\\x85\\\\\\xac\\001\\xc5pp\\177ן\\xac=`\\xc2\\xd5\\026sQ\\021\\xf9g)\\xb1\\xa8\\xa0Q\\x989\\017\\x96WJ\\027\"\nfile.show(\"Bases/data_frames.xlsx\")\nexcel_sheets(\"Bases/data_frames.xlsx\")## [1] \"iris\"  \"trees\"\niris_excel <- read_excel(path = \"Bases/data_frames.xlsx\", sheet = \"iris\")\nhead(iris_excel)## # A tibble: 6 × 5\n##   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n##          <dbl>       <dbl>        <dbl>       <dbl> <chr>  \n## 1          5.1         3.5          1.4         0.2 setosa \n## 2          4.9         3            1.4         0.2 setosa \n## 3          4.7         3.2          1.3         0.2 setosa \n## 4          4.6         3.1          1.5         0.2 setosa \n## 5          5           3.6          1.4         0.2 setosa \n## 6          5.4         3.9          1.7         0.4 setosa\ntrees_excel <- read_excel(path = \"Bases/data_frames.xlsx\", sheet = \"trees\")## New names:\n## • `` -> `...2`\n## • `` -> `...3`\n## • `` -> `...4`\n## • `` -> `...5`\n## • `` -> `...6`\n# Resultado\ntrees_excel## # A tibble: 34 × 6\n##    `Datos trees`  ...2  ...3  ...4 ...5  ...6                                                   \n##    <chr>         <dbl> <dbl> <dbl> <lgl> <chr>                                                  \n##  1 <NA>           NA      NA  NA   NA    <NA>                                                   \n##  2 <NA>            8.3    70  10.3 NA    <NA>                                                   \n##  3 <NA>            8.6    65  10.3 NA    <NA>                                                   \n##  4 <NA>            8.8    63  10.2 NA    Los nombres de las variables son: Girth, Height, Volume\n##  5 <NA>           10.5    72  16.4 NA    <NA>                                                   \n##  6 <NA>           10.7    81  18.8 NA    <NA>                                                   \n##  7 <NA>           10.8    83  19.7 NA    <NA>                                                   \n##  8 <NA>           11      66  15.6 NA    <NA>                                                   \n##  9 <NA>           11      75  18.2 NA    <NA>                                                   \n## 10 <NA>           11.1    80  22.6 NA    <NA>                                                   \n## # … with 24 more rows\ntrees_excel <- read_excel(path = \"Bases/data_frames.xlsx\", sheet = \"trees\", \n                          range = \"B3:D33\", \n                          col_names = c(\"Girth\", \"Height\", \"Volume\"))\n# Resultado\ntrees_excel## # A tibble: 31 × 3\n##    Girth Height Volume\n##    <dbl>  <dbl>  <dbl>\n##  1   8.3     70   10.3\n##  2   8.6     65   10.3\n##  3   8.8     63   10.2\n##  4  10.5     72   16.4\n##  5  10.7     81   18.8\n##  6  10.8     83   19.7\n##  7  11       66   15.6\n##  8  11       75   18.2\n##  9  11.1     80   22.6\n## 10  11.2     75   19.9\n## # … with 21 more rows"},{"path":"importar-y-exportar-datos.html","id":"datos-de-paquetes-estadísticos-comerciales-spss-sas-y-stata","chapter":"12 Importar y exportar datos","heading":"12.6 Datos de paquetes estadísticos comerciales (SPSS, SAS y STATA)","text":"En ciertas disciplinas, el uso de determinados paquetes estadísticos comerciales es sumamente común. Si por ejemplo, en Psicología el paquete SPSS Statistics de IBM es el paquete estadístico comercial más usado. Si se es psicólogo o psicóloga, es altamente probable encontrar datos contenidos en archivos con extensión .sav, el tipo de archivo nativo de SPSS Statistics.Por lo tanto, es conveniente importar y exportar datos almacenados en archivos compatibles con paquetes estadísticos comerciales, pues esto nos permitirá usar datos ya existentes compatibles con ellos y colaborar con otras personas.Para este fin, se usa el paquete haven.Para usar las funciones de haven, se caraga la sesión de trabajo.Las siguientes funciones de del paquete haven son usadas para importar datos. Todas estas funciones piden como argumento file la ruta y nombre del archivo importar, si se especifica ruta, será buscado en el directorio de trabajo.read_spss(): SPSS Statistics, archivos con extensión sav, zsav y por.read_sav(): SPSS Statistics, sólo archivos sav, zsav.read_sas(): SAS, archivos sas7bdat.read_xpt: SAS, archivos xpt.read_stata(): Stata, archivos dta.Todas importan los datos como un data frame.También se pueden exportar los data frames creados en R como archivos compatibles con estos programas con las siguientes funciones. Todas piden el argumento file, con la ruta y nombre del archivo crear. Es muy importante que poner como nombre de archivo uno con la extensión correcta para cada paquete.write_sav(): SPSS Statistics, archivos sav, zsav o por.write_sas(): SAS, archivos sas7bda.write_xpt(): SAS, archivos xpt.write_dta(): Stata, archivos dta.Como siempre, se pueden leer sobre las demás funciones en el paquete haven en su documentación, llamando help(package = \"haven\").","code":"\ninstall.packages(\"haven\")\nlibrary(haven)"},{"path":"dplyr-data-manipulation.html","id":"dplyr-data-manipulation","chapter":"13 Dplyr (Data Manipulation)","heading":"13 Dplyr (Data Manipulation)","text":"","code":""},{"path":"dplyr-data-manipulation.html","id":"data-frames-1","chapter":"13 Dplyr (Data Manipulation)","heading":"13.1 Data Frames","text":"El Data Frames es una estructura de datos clave en estadísticas y en R. La estructura básica de un data.frame es que hay una observación por fila y cada columna que representa una variable, una medida, característica o característica de esa observación. R tiene una implementación interna de tramas de datos que probablemente sea la que usará con más frecuencia. Sin embargo, hay paquetes en CRAN que implementan data frames través de cosas como bases de datos relacionales que le permiten operar en data frames muy grandes.Dada la importancia de administrar data frames, es importante que se tengan buenas herramientas para manejarlos. En capítulos anteriores ya se ha discutido algunas herramientas como la función subset() y el uso de operadores [ y $ para extraer subconjuntos de data frames. Sin embargo, otras operaciones, como filtrar, reordenar y colapsar, menudo pueden ser operaciones tediosas en R cuya sintaxis es muy intuitiva. El paquete dplyr está diseñado para mitigar muchos de estos problemas y proporcionar un conjunto de rutinas altamente optimizado específicamente para tratar con tramas de datos.","code":""},{"path":"dplyr-data-manipulation.html","id":"el-paquete-dplyr","chapter":"13 Dplyr (Data Manipulation)","heading":"13.2 El paquete dplyr","text":"El paquete dplyr proporciona ninguna funcionalidad “nueva” R per se, en el sentido de que todo lo que hace dplyr ya se podría hacer con R base, pero en gran medida simplifica la funcionalidad existente en R.Una contribución importante del paquete dplyr es que proporciona una “gramática” (en particular, verbos) para la manipulación de datos y para operar en tramas de datos. Con esta gramática, puede comunicar con sensatez qué es lo que está haciendo en un data.frame que otras personas pueden entender (suponiendo que también conozcan la gramática). Esto es útil porque proporciona una abstracción para la manipulación de datos que antes existía.","code":""},{"path":"dplyr-data-manipulation.html","id":"gramática","chapter":"13 Dplyr (Data Manipulation)","heading":"13.3 Gramática","text":"Algunos de los “verbos” clave proporcionados por el paquete dplyr son:select : devuelve un subconjunto de las columnas de un data.frame, usando una notación flexibleselect : devuelve un subconjunto de las columnas de un data.frame, usando una notación flexiblefiltro : extrae un subconjunto de filas de un data.frame basado en condiciones lógicasfiltro : extrae un subconjunto de filas de un data.frame basado en condiciones lógicasarrange : reordenar las filas de un data.framearrange : reordenar las filas de un data.framerename : cambia el nombre de las variables en un data.framerename : cambia el nombre de las variables en un data.framemutate : agregar nuevas variables/columnas o transformar variables existentesmutate : agregar nuevas variables/columnas o transformar variables existentessummarise / summarize : generar estadísticas resumidas de diferentes variables en el data.frame, posiblemente dentro de los estratos.summarise / summarize : generar estadísticas resumidas de diferentes variables en el data.frame, posiblemente dentro de los estratos.%>% : el operador “tubería” o pipeline se usa para conectar múltiples acciones verbales en un solo código como una tubería.%>% : el operador “tubería” o pipeline se usa para conectar múltiples acciones verbales en un solo código como una tubería.El paquete dplyr como un número de sus propios tipos de datos que aprovecha. Por ejemplo, hay un práctico método de print que impide imprimir una gran cantidad de datos en la consola. La mayoría de las veces, estos tipos de datos adicionales son transparentes para el usuario y es necesario preocuparse por ellos.","code":""},{"path":"dplyr-data-manipulation.html","id":"propiedades-comunes-de-la-función-dplyr","chapter":"13 Dplyr (Data Manipulation)","heading":"13.3.1 Propiedades comunes de la función dplyr","text":"Todas las funciones que se discutiran tendrán algunas características comunes. En particular:El primer argumento es un data.frame.El primer argumento es un data.frame.Los argumentos subsiguientes describen qué hacer con el data.frame especificado en el primer argumento, y puede hacer referencia las columnas en el data.frame directamente sin usar el operador $ (solo usando los nombres de las columnas).Los argumentos subsiguientes describen qué hacer con el data.frame especificado en el primer argumento, y puede hacer referencia las columnas en el data.frame directamente sin usar el operador $ (solo usando los nombres de las columnas).El resultado de retorno de una función es un nuevo data.frame.El resultado de retorno de una función es un nuevo data.frame.Los data frames deben estar correctamente formateados y anotados para que todo esto sea útil. En particular, los datos deben estar ordenados. En resumen, debe haber una observación por fila y cada columna debe representar un rasgo o característica de esa observación.Los data frames deben estar correctamente formateados y anotados para que todo esto sea útil. En particular, los datos deben estar ordenados. En resumen, debe haber una observación por fila y cada columna debe representar un rasgo o característica de esa observación.","code":""},{"path":"dplyr-data-manipulation.html","id":"instalar-el-paquete-dplyr","chapter":"13 Dplyr (Data Manipulation)","heading":"13.4 Instalar el paquete dplyr","text":"El paquete dplyr se puede instalar desde CRAN o desde GitHub usando el paquete devtools y la función install_github() . El repositorio de GitHub normalmente contendrá las últimas actualizaciones del paquete y la versión de desarrollo.Para instalar desde CRAN, simplemente se ejecuta.Para instalar desde GitHub puedes ejecutarDespués de instalar el paquete, es importante cargarlo en la sesión de R con la función library() .Es posible que se reciban algunas advertencias cuando se carga el paquete porque hay funciones en el paquete dplyr que tienen el mismo nombre que funciones en otros paquetes. Por ahora se pueden ignorar las advertencias.","code":"\ninstalar.paquetes ( \"dplyr\" )\ndevtools::install_github(\"hadley/dplyr \")\nlibrary(dplyr)"},{"path":"dplyr-data-manipulation.html","id":"select","chapter":"13 Dplyr (Data Manipulation)","heading":"13.5 select()","text":"Se usarán un conjunto de datos que contiene datos de temperatura y contaminación del aire para la [ciudad de Chicago] (http://www.biostat.jhsph.edu/~rpeng/leanpub/rprog/chicago_data.zip) en EE. UU. El conjunto de datos está disponible en mi sitio web.Después de descomprimir el archivo, puede cargar los datos en R usando la función readRDS() .Se peden ver algunas características básicas del conjunto de datos con las funciones dim() y str() .La función select() se puede usar para seleccionar columnas de un data.frame en el que se desea enfocar. menudo, se tendrá un data.frame que contendrá “muchos datos”, pero cualquier análisis dado solo se puede usar un subconjunto de variables u observaciones. La función select() permite obtener las pocas columnas que pueda necesitar.Supongamos que se quisiera tomar solo las primeras 3 columnas. Hay algunas maneras de hacer esto. Se podría, por ejemplo, utilizar índices numéricos. Pero también se puede usar los nombres directamente.Tenga en cuenta que : normalmente se puede usar con nombres o cadenas, pero dentro de la función select() see puede usarla para especificar un rango de nombres de variables.También se pueden omitir variables usando la función select() usando el signo negativo. Con select() se puede hacer.Lo que indica que se deben incluir todas las variables excepto las variables city dptp . El código equivalente en base R base sería:es muy relamente intuitivo.La función select() también permite una sintaxis especial que permite especificar nombres de variables basados en patrones. Por ejemplo, si se quisiera mantener todas las variables que terminan en “2”, se podría hacer:O si se quisiera mantener todas las variables que comienzan con una “d”, podríamos hacerTambién se pueden usar expresiones regulares más generales si es necesario. Consulte la página de ayuda ( ?select ) para obtener más detalles.","code":"\nchicago <- readRDS(\"Bases/chicago.rds\")\ndim(chicago)\n## [1] 6940    8\n\nstr(chicago)\n## 'data.frame':    6940 obs. of  8 variables:\n##  $ city      : chr  \"chic\" \"chic\" \"chic\" \"chic\" ...\n##  $ tmpd      : num  31.5 33 33 29 32 40 34.5 29 26.5 32.5 ...\n##  $ dptp      : num  31.5 29.9 27.4 28.6 28.9 ...\n##  $ date      : Date, format: \"1987-01-01\" \"1987-01-02\" \"1987-01-03\" \"1987-01-04\" ...\n##  $ pm25tmean2: num  NA NA NA NA NA NA NA NA NA NA ...\n##  $ pm10tmean2: num  34 NA 34.2 47 NA ...\n##  $ o3tmean2  : num  4.25 3.3 3.33 4.38 4.75 ...\n##  $ no2tmean2 : num  20 23.2 23.8 30.4 30.3 ...\nnames(chicago)[1:3]\n## [1] \"city\" \"tmpd\" \"dptp\"\n\nsubset <- select(chicago, city:dptp) \nhead(subset)\n##   city tmpd   dptp\n## 1 chic 31.5 31.500\n## 2 chic 33.0 29.875\n## 3 chic 33.0 27.375\n## 4 chic 29.0 28.625\n## 5 chic 32.0 28.875\n## 6 chic 40.0 35.125\n\nsubset <- select(chicago, 1:3)\nhead(subset)\n##   city tmpd   dptp\n## 1 chic 31.5 31.500\n## 2 chic 33.0 29.875\n## 3 chic 33.0 27.375\n## 4 chic 29.0 28.625\n## 5 chic 32.0 28.875\n## 6 chic 40.0 35.125\nselect(chicago, -(city:dptp))\ni <- match(\"city\", names(chicago))\nj <- match(\"dptp\", names(chicago))\nhead(chicago[, -(i:j)])\nsubset <- select(chicago, ends_with(\"2\"))\nstr(subset)\n## 'data.frame':    6940 obs. of  4 variables:\n##  $ pm25tmean2: num  NA NA NA NA NA NA NA NA NA NA ...\n##  $ pm10tmean2: num  34 NA 34.2 47 NA ...\n##  $ o3tmean2  : num  4.25 3.3 3.33 4.38 4.75 ...\n##  $ no2tmean2 : num  20 23.2 23.8 30.4 30.3 ...\nsubset <- select(chicago, starts_with(\"d\"))\nstr(subset)\n## 'data.frame':    6940 obs. of  2 variables:\n##  $ dptp: num  31.5 29.9 27.4 28.6 28.9 ...\n##  $ date: Date, format: \"1987-01-01\" \"1987-01-02\" \"1987-01-03\" \"1987-01-04\" ..."},{"path":"dplyr-data-manipulation.html","id":"filter","chapter":"13 Dplyr (Data Manipulation)","heading":"13.6 filter()","text":"La función filter() se utiliza para extraer subconjuntos de filas de un data.frame. Esta función es similar la función subset() existente en R, pero es un poco más rápida e intuitiva.Suponemos que se quisiera extraer las filas del data.frame chicago donde los niveles de PM2.5 son superiores 30 (que es un nivel razonablemente alto), se podría hacer:Se puede ver que ahora solo hay filas 194 en el data.frame y la distribución de los valores pm25tmean2 es.Se puede colocar una secuencia lógica arbitrariamente compleja dentro de filter() , por lo que se podría extraer las filas donde PM2.5 es superior 30 y la temperatura es superior 80 grados Fahrenheit.Ahora solo hay observaciones 17 donde se cumplen ambas condiciones.","code":"\nchic.f <- filter(chicago, pm25tmean2 > 30)\nstr(chic.f)\n## 'data.frame':    194 obs. of  8 variables:\n##  $ city      : chr  \"chic\" \"chic\" \"chic\" \"chic\" ...\n##  $ tmpd      : num  23 28 55 59 57 57 75 61 73 78 ...\n##  $ dptp      : num  21.9 25.8 51.3 53.7 52 56 65.8 59 60.3 67.1 ...\n##  $ date      : Date, format: \"1998-01-17\" \"1998-01-23\" \"1998-04-30\" \"1998-05-01\" ...\n##  $ pm25tmean2: num  38.1 34 39.4 35.4 33.3 ...\n##  $ pm10tmean2: num  32.5 38.7 34 28.5 35 ...\n##  $ o3tmean2  : num  3.18 1.75 10.79 14.3 20.66 ...\n##  $ no2tmean2 : num  25.3 29.4 25.3 31.4 26.8 ...\nsummary(chic.f$pm25tmean2)\n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##   30.05   32.12   35.04   36.63   39.53   61.50\nchic.f <- filter(chicago, pm25tmean2 > 30 & tmpd > 80)\nselect(chic.f, date, tmpd, pm25tmean2)\n##          date tmpd pm25tmean2\n## 1  1998-08-23   81   39.60000\n## 2  1998-09-06   81   31.50000\n## 3  2001-07-20   82   32.30000\n## 4  2001-08-01   84   43.70000\n## 5  2001-08-08   85   38.83750\n## 6  2001-08-09   84   38.20000\n## 7  2002-06-20   82   33.00000\n## 8  2002-06-23   82   42.50000\n## 9  2002-07-08   81   33.10000\n## 10 2002-07-18   82   38.85000\n## 11 2003-06-25   82   33.90000\n## 12 2003-07-04   84   32.90000\n## 13 2005-06-24   86   31.85714\n## 14 2005-06-27   82   51.53750\n## 15 2005-06-28   85   31.20000\n## 16 2005-07-17   84   32.70000\n## 17 2005-08-03   84   37.90000"},{"path":"dplyr-data-manipulation.html","id":"arrange","chapter":"13 Dplyr (Data Manipulation)","heading":"13.7 arrange()","text":"La función arrange() se usa para reordenar las filas de un data.frame de acuerdo con una de las variables/columnas. Reordenar filas de un data.frame (manteniendo el orden correspondiente de otras columnas) normalmente es una molestia en R. La función arrange() simplifica bastante el proceso.Aquí se puede ordenar las filas del data.frame por fecha, de modo que la primera fila sea la observación más antigua (la más antigua) y la última fila sea la observación más reciente (la más reciente).Ahora se puedne comprobar las primeras filasy las últimas filas.Las columnas también se pueden organizar en orden descendente mediante el uso del operador especial desc() .Mirando las primeras tres y últimas tres filas se muestran las fechas en orden descendente.","code":"\nchicago <- arrange(chicago, date)\nhead(select(chicago, date, pm25tmean2), 3)##         date pm25tmean2\n## 1 1987-01-01         NA\n## 2 1987-01-02         NA\n## 3 1987-01-03         NA\ntail(select(chicago, date, pm25tmean2), 3)##            date pm25tmean2\n## 6938 2005-12-29    7.45000\n## 6939 2005-12-30   15.05714\n## 6940 2005-12-31   15.00000\nchicago <- arrange(chicago, desc(date))\nhead(select(chicago, date, pm25tmean2), 3)\n##         date pm25tmean2\n## 1 2005-12-31   15.00000\n## 2 2005-12-30   15.05714\n## 3 2005-12-29    7.45000\ntail(select(chicago, date, pm25tmean2), 3)\n##            date pm25tmean2\n## 6938 1987-01-03         NA\n## 6939 1987-01-02         NA\n## 6940 1987-01-01         NA"},{"path":"dplyr-data-manipulation.html","id":"rename","chapter":"13 Dplyr (Data Manipulation)","heading":"13.8 rename()","text":"Cambiar el nombre de una variable en un data.frame en R es sorprendentemente difícil de hacer. La función rename() está diseñada para facilitar este proceso.Aquí se pueden ver los nombres de las primeras cinco variables en el data.frame chicago .Se supone que la columna dptp representa la temperatura del punto de rocío y la columna pm25tmean2 proporciona los datos de PM2.5. Sin embargo, estos nombres son bastante oscuros o incómodos y probablemente se les cambie el nombre algo más sensato.La sintaxis dentro de la función rename() es tener el nuevo nombre en el lado izquierdo del signo = y el nombre anterior en el lado derecho.Lo dejo como ejercicio para que el lector descubra cómo hacer esto en base R sin dplyr .","code":"\nhead(chicago[, 1:5], 3)\n##   city tmpd dptp       date pm25tmean2\n## 1 chic   35 30.1 2005-12-31   15.00000\n## 2 chic   36 31.0 2005-12-30   15.05714\n## 3 chic   35 29.4 2005-12-29    7.45000\nchicago <- rename(chicago, dewpoint = dptp,\n                  pm25 = pm25tmean2)\nhead(chicago[, 1:5], 3)\n##   city tmpd dewpoint       date     pm25\n## 1 chic   35     30.1 2005-12-31 15.00000\n## 2 chic   36     31.0 2005-12-30 15.05714\n## 3 chic   35     29.4 2005-12-29  7.45000"},{"path":"dplyr-data-manipulation.html","id":"mutate","chapter":"13 Dplyr (Data Manipulation)","heading":"13.9 mutate()","text":"La función mutate() existe para calcular transformaciones de variables en un data.frame. menudo, desea crear nuevas variables derivadas de variables existentes y mutate() proporciona una interfaz limpia para hacerlo.Por ejemplo, con los datos de contaminación del aire, menudo se desea eliminar la tendencia de los datos restando la media de los datos. De esa manera, se puede ver si el nivel de contaminación del aire de un día determinado es mayor o menor que el promedio (en lugar de ver su nivel absoluto).Se crea una variable pm25detrend que resta la media de la variable pm25.También está la función transmute() relacionada , que hace lo mismo que mutate() pero luego elimina todas las variables transformadas .Aquí se elimina la tendencia de las variables PM10 y ozono (O3).Teniendo en cuenta que solo hay dos columnas en el data.frame transmutado.","code":"\nchicago <- mutate(chicago, pm25detrend = pm25 - mean(pm25, na.rm = TRUE))\nhead(chicago)\n##   city tmpd dewpoint       date     pm25 pm10tmean2  o3tmean2 no2tmean2 pm25detrend\n## 1 chic   35     30.1 2005-12-31 15.00000       23.5  2.531250  13.25000   -1.230958\n## 2 chic   36     31.0 2005-12-30 15.05714       19.2  3.034420  22.80556   -1.173815\n## 3 chic   35     29.4 2005-12-29  7.45000       23.5  6.794837  19.97222   -8.780958\n## 4 chic   37     34.5 2005-12-28 17.75000       27.5  3.260417  19.28563    1.519042\n## 5 chic   40     33.6 2005-12-27 23.56000       27.0  4.468750  23.50000    7.329042\n## 6 chic   35     29.6 2005-12-26  8.40000        8.5 14.041667  16.81944   -7.830958\nhead(transmute(chicago, \n               pm10detrend = pm10tmean2 - mean(pm10tmean2, na.rm = TRUE),\n               o3detrend = o3tmean2 - mean(o3tmean2, na.rm = TRUE)))\n##   pm10detrend  o3detrend\n## 1  -10.395206 -16.904263\n## 2  -14.695206 -16.401093\n## 3  -10.395206 -12.640676\n## 4   -6.395206 -16.175096\n## 5   -6.895206 -14.966763\n## 6  -25.395206  -5.393846"},{"path":"dplyr-data-manipulation.html","id":"group_by","chapter":"13 Dplyr (Data Manipulation)","heading":"13.10 group_by()","text":"La función group_by() se utiliza para generar estadísticas de resumen partir del data.frame dentro de los estratos definidos por una variable. Por ejemplo, en este conjunto de datos de contaminación del aire, es posible que se desee saber cuál es el nivel promedio anual de PM2.5. Así que el estrato es el año, y eso es algo que se puede derivar de la variable date . Junto con la función group_by() ,menudo se usa la función summarize().La operación general aquí es una combinación de dividir un data.frame en partes separadas definidas por una variable o grupo de variables por group_by(), y luego aplicar una función de resumen través de esos subconjuntos, utilizando la función summarise().Primero, se puede crear una variable year usando .POSIXlt() .Ahora se puede crear un data.frame separado que divida el data.frame original por año.Finalmente, se calculan las estadísticas resumidas para cada año en el data.frame con la función summarise() .summarise() devuelve un data.frame con año como la primera columna, y luego los promedios anuales de pm25 , o3 y no2 .En un ejemplo un poco más complicado, se podría querer saber cuáles son los niveles promedio de ozono ( o3 ) y dióxido de nitrógeno ( no2 ) dentro de los quintiles de pm25 . Una forma más ingeniosa de hacer esto sería través de un modelo de regresión, pero en realidad se puede hacerlo rápidamente con group_by() y summarize() .Primero, se puede crear una variable categórica de pm25 dividida en quintiles.Ahora se puede agrupar el data.frame por la variable pm25.quint.Finalmente, se puede calcular la media de o3 y no2 dentro de los quintiles de pm25 .De la tabla, parece que hay una fuerte relación entre pm25 y o3 , pero parece haber una correlación positiva entre pm25 y no2 . Los modelos estadísticos más sofisticados pueden ayudar proporcionar respuestas precisas estas preguntas, pero una simple aplicación de las funciones dplyr menudo puede ayudarlo llegar hasta allí.","code":"\nchicago <- mutate(chicago, year = as.POSIXlt(date)$year + 1900)\nyears <- group_by(chicago, year)\nsummarise(years, \n           pm25 = mean(pm25, na.rm = TRUE), \n           o3 = max(o3tmean2, na.rm = TRUE), \n           no2 = median(no2tmean2, na.rm = TRUE),\n           .groups = \"drop\")## # A tibble: 19 × 4\n##     year  pm25    o3   no2\n##    <dbl> <dbl> <dbl> <dbl>\n##  1  1987 NaN    63.0  23.5\n##  2  1988 NaN    61.7  24.5\n##  3  1989 NaN    59.7  26.1\n##  4  1990 NaN    52.2  22.6\n##  5  1991 NaN    63.1  21.4\n##  6  1992 NaN    50.8  24.8\n##  7  1993 NaN    44.3  25.8\n##  8  1994 NaN    52.2  28.5\n##  9  1995 NaN    66.6  27.3\n## 10  1996 NaN    58.4  26.4\n## 11  1997 NaN    56.5  25.5\n## 12  1998  18.3  50.7  24.6\n## 13  1999  18.5  57.5  24.7\n## 14  2000  16.9  55.8  23.5\n## 15  2001  16.9  51.8  25.1\n## 16  2002  15.3  54.9  22.7\n## 17  2003  15.2  56.2  24.6\n## 18  2004  14.6  44.5  23.4\n## 19  2005  16.2  58.8  22.6\nqq <- quantile(chicago$pm25, seq(0, 1, 0.2), na.rm = TRUE)\nchicago <- mutate(chicago, pm25.quint = cut(pm25, qq))\nquint <- group_by(chicago, pm25.quint)\nsummarize(quint, o3 = mean(o3tmean2, na.rm = TRUE), \n          no2 = mean(no2tmean2, na.rm = TRUE),\n          .groups = \"drop\")## # A tibble: 6 × 3\n##   pm25.quint     o3   no2\n##   <fct>       <dbl> <dbl>\n## 1 (1.7,8.7]    21.7  18.0\n## 2 (8.7,12.4]   20.4  22.1\n## 3 (12.4,16.7]  20.7  24.4\n## 4 (16.7,22.6]  19.9  27.3\n## 5 (22.6,61.5]  20.3  29.6\n## 6 <NA>         18.8  25.8"},{"path":"dplyr-data-manipulation.html","id":"section","chapter":"13 Dplyr (Data Manipulation)","heading":"13.11 %>%","text":"El operador de canalización %>% es muy útil para encadenar varias funciones dplyr en una secuencia de operaciones. Notesé que arriba que cada vez que queríamos aplicar más de una función, la secuencia queda enterrada en una secuencia de llamadas funciones anidadas que es difícil de leer, es decir.Este anidamiento es una forma natural de pensar en una secuencia de operaciones. El operador %>% permite encadenar operaciones de izquierda derecha, es decirTomando el ejemplo anterior donde se calculó la media de o3 y no2 dentro de los quintiles de pm25. Se tuvo que:crea una nueva variable pm25.quintdividir el data.frame por esa nueva variable.calcular la media de o3 y no2 en los subgrupos definidos por pm25.quint.Eso se puede hacer con la siguiente secuencia en una sola expresión R.De esta manera, se tiene que crear un conjunto de variables temporales en el camino o crear una secuencia anidada masiva de llamadas funciones.Observesé en el código anterior que paso el data.frame chicago la primera llamada y después se uso mutate(), pero luego se tuvo que pasar el primer argumento group_by() o summarize() . Una vez que se viaja por la tubería con %>% , el primer argumento se toma como la salida del elemento anterior en la tubería.Otro ejemplo podría ser calcular el nivel promedio de contaminantes por mes. Esto podría ser útil para ver si hay tendencias estacionales en los datos.Aquí se puede ver que o3 tiende ser bajo en los meses de invierno y alto en verano, mientras que no2 es más alto en invierno y más bajo en verano.","code":"\nthird(second(first(x)))\nfirst(x) %>% second %>% third\nchicago %>% \n  mutate(., pm25.quint = cut(pm25, qq)) %>%    \n   group_by(pm25.quint) %>% \n    summarize(o3 = mean(o3tmean2, na.rm = TRUE), \n               no2 = mean(no2tmean2, na.rm = TRUE),\n                .groups = \"drop\")## # A tibble: 6 × 3\n##   pm25.quint     o3   no2\n##   <fct>       <dbl> <dbl>\n## 1 (1.7,8.7]    21.7  18.0\n## 2 (8.7,12.4]   20.4  22.1\n## 3 (12.4,16.7]  20.7  24.4\n## 4 (16.7,22.6]  19.9  27.3\n## 5 (22.6,61.5]  20.3  29.6\n## 6 <NA>         18.8  25.8\nmutate(chicago, month = as.POSIXlt(date)$mon + 1) %>% \n        group_by(month) %>% \n        summarize(pm25 = mean(pm25, na.rm = TRUE), \n                  o3 = max(o3tmean2, na.rm = TRUE), \n                  no2 = median(no2tmean2, na.rm = TRUE),\n                  .groups = \"drop\")## # A tibble: 12 × 4\n##    month  pm25    o3   no2\n##    <dbl> <dbl> <dbl> <dbl>\n##  1     1  17.8  28.2  25.4\n##  2     2  20.4  37.4  26.8\n##  3     3  17.4  39.0  26.8\n##  4     4  13.9  47.9  25.0\n##  5     5  14.1  52.8  24.2\n##  6     6  15.9  66.6  25.0\n##  7     7  16.6  59.5  22.4\n##  8     8  16.9  54.0  23.0\n##  9     9  15.9  57.5  24.5\n## 10    10  14.2  47.1  24.2\n## 11    11  15.2  29.5  23.6\n## 12    12  17.5  27.7  24.5"},{"path":"dplyr-data-manipulation.html","id":"resumen","chapter":"13 Dplyr (Data Manipulation)","heading":"13.12 Resumen","text":"El paquete dplyr proporciona un conjunto conciso de operaciones para administrar data frames. Con estas funciones se puede realizar una serie de operaciones complejas en tan solo unas pocas líneas de código. En particular, menudo se puede realizar los comienzos de un análisis exploratorio con la poderosa combinación de group_by() y summarize() .Una vez que aprende la gramática dplyr , hay algunos beneficios adicionales;dplyr puede funcionar con otros “backends” de data frames, como bases de datos SQL. Hay una interfaz SQL para bases de datos relacionales través del paquete DBI.dplyr puede funcionar con otros “backends” de data frames, como bases de datos SQL. Hay una interfaz SQL para bases de datos relacionales través del paquete DBI.dplyr se puede integrar con el paquete data.table para tablas grandes y rápidas.dplyr se puede integrar con el paquete data.table para tablas grandes y rápidas.El paquete dplyr es una forma práctica de simplificar y acelerar el código de administración de data frames.También existen múltiples paqueterías que permiten la incorporación de dplyr en los modelos estadísticos.","code":""},{"path":"ggplot.html","id":"ggplot","chapter":"14 ggplot","heading":"14 ggplot","text":"ggplot2\nggplot2\nggplot2 extensions - gallery","code":""},{"path":"references.html","id":"references","chapter":"References","heading":"References","text":"","code":""},{"path":"references.html","id":"librerías","chapter":"References","heading":"14.1 Librerías","text":"Librerías que se usaron en el trabajoThis work  Diana Villasana Ocampo licensed Creative Commons Attribution 4.0 International License.Manual de R. (n.d.). Retrieved September 2022, https://fhernanb.github.io/Manual-de-R/RMarkdown Referencia Guide (n.d.) Retrieved September 2022, https://www.rstudio.com/wp-content/uploads/2015/03/rmarkdown-reference.pdf","code":"## [1] \"ggplot2\"   \"dplyr\"     \"haven\"     \"readxl\"    \"rmarkdown\" \"knitr\""}]
